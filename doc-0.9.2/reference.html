<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head>
  <meta content="text/html; charset=UTF-8" http-equiv="content-type" />
  <title>Savonet / Liquidsoap 0.9.2 :: Multimedia Stream Generation</title>
  <link href="../css/new.css" type="text/css" rel="stylesheet" />
  <link href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.8.17/themes/base/jquery-ui.css" type="text/css" rel="stylesheet" />
  <script type="text/javascript" src="http://www.google.com/jsapi"></script>
  <link rel="shortcut icon" href="../favicon.ico" />
  <script>
    google.load("jquery", "1.6.1");
    google.load("jqueryui", "1.8.14");
  </script>
  <script type="text/javascript" src="../js/jQuery.syntax/jquery.syntax.min.js"></script>
  <script type="text/javascript" src="../js/liq-jquery.js"></script>
</head>
<body>
  <div class="menu">
    <ul>
      <li id="menu-developers">
        <a href="https://github.com/savonet/liquidsoap/issues" target="_blank">developers</a></li>
      <li id="menu-flows"><a href="http://flows.liquidsoap.fm/">Flows!</a></li>
      <li id="menu-doc-api-www">
        <a href="reference.html">API</a></li>
      <li id="menu-support">
        <a href="documentation.html">documentation</a></li>
      <li id="menu-download">
        <a href="../download.html">download</a></li>
      <li id="menu-about">
        <a href="../index.html">about</a></li>
    </ul>
  </div>
  <div class="section" id="main">
    <h1>Liquidsoap 0.9.2 : Language reference</h1>
    <div class="content">
      <h2>Liquidsoap scripting language reference</h2>
<h3>Categories</h3>
<p>
The <b>Source / ...</b> categories contain all functions that return sources.
The <b>Input</b> functions are those which build elementary sources
(playing files, synthesizing sound, etc.).
The <b>Output</b> functions are those which take a source and register it
for being streamed to the outside (file, soundcard, audio server, etc.).
The <b>Visualization</b> functions are experimental ones that let you 
visualize in real-time some aspects of the audio stream.
The <b>Sound Processing</b> functions are those which basically work on the source 
as a continuous audio stream. They would typically be mixers of streams,
audio effects or analysis.
Finally, <b>Track Processing</b> functions are basically all 
others, often having a behaviour that depends on or affects the extra 
information that liquidsoap puts in streams: track limits and metadata.
</p>
<ul>
<li>
<a href="#SourceInput">Source / Input</a></li>
<li>
<a href="#SourceMIDIProcessing">Source / MIDI Processing</a></li>
<li>
<a href="#SourceOutput">Source / Output</a></li>
<li>
<a href="#SourceSoundProcessing">Source / Sound Processing</a></li>
<li>
<a href="#SourceSoundSynthesis">Source / Sound Synthesis</a></li>
<li>
<a href="#SourceTrackProcessing">Source / Track Processing</a></li>
<li>
<a href="#SourceVideoProcessing">Source / Video Processing</a></li>
<li>
<a href="#SourceVisualization">Source / Visualization</a></li>
<li>
<a href="#Bool">Bool</a></li>
<li>
<a href="#Control">Control</a></li>
<li>
<a href="#Deprecated">Deprecated</a></li>
<li>
<a href="#Interaction">Interaction</a></li>
<li>
<a href="#Liquidsoap">Liquidsoap</a></li>
<li>
<a href="#List">List</a></li>
<li>
<a href="#Math">Math</a></li>
<li>
<a href="#String">String</a></li>
<li>
<a href="#System">System</a></li>
<li>
<a href="#Uncategorized">Uncategorized</a></li>
</ul>
<h3><a name="SourceInput">Source / Input</a></h3>
<h5>blank</h5>
<pre class="syntax ">(?id:string, ?duration:float)-&gt;source</pre>
<p>
Produce silence.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>0.</code>): Duration of blank tracks in seconds, default means forever.</li>
</ul>
<h5>dolebrai</h5>
<pre class="syntax ">()-&gt;source</pre>
<p>
Relay the audio stream of Dolebraï, a libre music netradio running liquidsoap.
</p>
<h5>fail</h5>
<pre class="syntax ">()-&gt;source</pre>
<p>
Creates a source that fails to produce anything.
</p>
<h5>in</h5>
<pre class="syntax ">()-&gt;source</pre>
<p>
Create a source from the first available input driver in this list:
portaudio, alsa, oss, blank
</p>
<h5>input.alsa</h5>
<pre class="syntax ">(?id:string, ?bufferize:bool, ?device:string)
 -&gt;source</pre>
<p>
Stream from an ALSA input device.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>bufferize</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Bufferize input.</li>
<li>
<code>device</code> (<code>string</code> &ndash; defaults to <code>&quot;default&quot;</code>): Alsa device to use.</li>
</ul>
<h5>input.external</h5>
<pre class="syntax ">(?id:string, ?buffer:float, ?max:float,
 ?channels:int, ?samplerate:int, ?restart:bool,
 ?restart_on_error:bool, string)-&gt;source</pre>
<p>
Stream data from an external application.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>buffer</code> (<code>float</code> &ndash; defaults to <code>2.</code>): Duration of the pre-buffered data.</li>
<li>
<code>max</code> (<code>float</code> &ndash; defaults to <code>10.</code>): Maximum duration of the buffered data.</li>
<li>
<code>channels</code> (<code>int</code> &ndash; defaults to <code>2</code>): Number of channels.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>): Samplerate.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Restart process when exited.</li>
<li>
<code>restart_on_error</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart process when exited with error.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Command to execute.</li>
</ul>
<h5>input.harbor</h5>
<pre class="syntax ">(?id:string, ?buffer:float, ?max:float,
 ?on_connect:(([(string*string)])-&gt;unit),
 ?on_disconnect:(()-&gt;unit), ?user:string,
 ?password:string, ?auth:((string, string)-&gt;bool),
 ?dumpfile:string, ?logfile:string, ?debug:bool,
 string)-&gt;source</pre>
<p>
Retrieves the given http stream from the harbor.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>buffer</code> (<code>float</code> &ndash; defaults to <code>2.</code>): Duration of the pre-buffered data.</li>
<li>
<code>max</code> (<code>float</code> &ndash; defaults to <code>10.</code>): Maximum duration of the buffered data.</li>
<li>
<code>on_connect</code> (<code>([(string*string)])-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Function to execute when a source is connected. Its receives the list of headers, of the form: (“label”,“value”). All labels are lowercase.</li>
<li>
<code>on_disconnect</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Functions to excecute when a source is disconnected</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Source user. Override default if not empty.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Source password. Override default if not empty.</li>
<li>
<code>auth</code> (<code>(string, string)-&gt;bool</code> &ndash; defaults to <code>{false}</code>): Authentification function. <code>f(login,password)</code> returns <code>true</code> if the user should be granted access for this login. Override any other method if used.</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>logfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Log buffer status to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Run in debugging mode by not catching some exceptions.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Mountpoint to look for.</li>
</ul>
<h5>input.http</h5>
<pre class="syntax ">(?id:string, ?autostart:bool, ?bind_address:string,
 ?buffer:float, ?timeout:float,
 ?new_track_on_metadata:bool, ?force_mime:string,
 ?playlist_mode:string, ?poll_delay:float,
 ?max:float, ?logfile:string, ?debug:bool,
 ?user_agent:string, string)-&gt;source</pre>
<p>
Forwards the given http stream. The relay can be paused/resumed using the start/stop telnet commands.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>autostart</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Initially start relaying or not.</li>
<li>
<code>bind_address</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Address to bind on the local machine. This option can be useful if your machine is bound to multiple IPs. Empty means no bind address.</li>
<li>
<code>buffer</code> (<code>float</code> &ndash; defaults to <code>2.</code>): Duration of the pre-buffered data.</li>
<li>
<code>timeout</code> (<code>float</code> &ndash; defaults to <code>10.</code>): Timeout for http connection.</li>
<li>
<code>new_track_on_metadata</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Treat new metadata as new track.</li>
<li>
<code>force_mime</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force mime data type. Not used if empty.</li>
<li>
<code>playlist_mode</code> (<code>string</code> &ndash; defaults to <code>&quot;normal&quot;</code>): Valid modes are “normal”, “random”, “randomize” and “first”. The first ones have the same meaning as for the mode parameter of the playlist operator. The last one discards all entries but the first one.</li>
<li>
<code>poll_delay</code> (<code>float</code> &ndash; defaults to <code>2.</code>): Polling delay when trying to connect to the stream.</li>
<li>
<code>max</code> (<code>float</code> &ndash; defaults to <code>10.</code>): Maximum duration of the buffered data.</li>
<li>
<code>logfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Log buffer status to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Run in debugging mode, not catching some exceptions.</li>
<li>
<code>user_agent</code> (<code>string</code> &ndash; defaults to <code>&quot;liquidsoap/0.9.1+svn (Unix; ocaml 3.11.1)&quot;</code>): User agent.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): URL of an http stream (default port is 80).</li>
</ul>
<h5>input.jack</h5>
<pre class="syntax ">(?id:string, ?buffer_size:int, ?server:string)
 -&gt;source</pre>
<p>
Get stream from jack.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>buffer_size</code> (<code>int</code> &ndash; defaults to <code>2</code>): Set buffer size, in frames. Must be &gt;= 1.</li>
<li>
<code>server</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Jack server to connect to.</li>
</ul>
<h5>input.jack.legacy</h5>
<pre class="syntax ">(?id:string, ?ports:[string], ?synchronize:bool)
 -&gt;source</pre>
<p>
WARNING: This is DEPRECATED!
</p>
<p>
Deprecated jack input.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>ports</code> (<code>[string]</code> &ndash; defaults to <code>[ &quot;input_0&quot;, &quot;input_1&quot; ]</code>): Port names.</li>
<li>
<code>synchronize</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Synchronize on jack input.</li>
</ul>
<h5>input.lastfm</h5>
<pre class="syntax ">(?id:string, ?autostart:bool, ?buffer:float,
 ?bind_address:string, ?timeout:float,
 ?poll_delay:float, ?submit:bool,
 ?submit_host:string, ?submit_port:int,
 ?new_track_on_metadata:bool, ?debug:bool,
 ?max:float, ?user_agent:string, string)-&gt;source</pre>
<p>
Forwards the given lastfm stream. The relay can be paused/resumed using the start/stop telnet commands.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>autostart</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Initially start relaying or not.</li>
<li>
<code>buffer</code> (<code>float</code> &ndash; defaults to <code>2.</code>): Duration of the pre-buffered data.</li>
<li>
<code>bind_address</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): address to bind on the local machine. This option can be useful if your machine is bound to multiple IPs. “” means no bind address.</li>
<li>
<code>timeout</code> (<code>float</code> &ndash; defaults to <code>10.</code>): Timeout for HTTP connections.</li>
<li>
<code>poll_delay</code> (<code>float</code> &ndash; defaults to <code>2.</code>): Polling delay.</li>
<li>
<code>submit</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Submit song to Audioscrobbler. Only when the url is not anonymous, e.g. <code>lastfm://user:password@artist/foo</code>.</li>
<li>
<code>submit_host</code> (<code>string</code> &ndash; defaults to <code>&quot;post.audioscrobbler.com&quot;</code>): Host for audioscrobbling submissions.</li>
<li>
<code>submit_port</code> (<code>int</code> &ndash; defaults to <code>80</code>): Port for audioscrobbling submissions.</li>
<li>
<code>new_track_on_metadata</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Treat new metadata as new track.</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Run in debugging mode by not catching some exceptions.</li>
<li>
<code>max</code> (<code>float</code> &ndash; defaults to <code>10.</code>): Maximum duration of the buffered data.</li>
<li>
<code>user_agent</code> (<code>string</code> &ndash; defaults to <code>&quot;liquidsoap/0.9.1+svn (Unix; ocaml 3.11.1)&quot;</code>): User agent.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): URI of a lastfm stream (e.g. lastfm://user/toots5446/playlist).</li>
</ul>
<h5>input.marshal</h5>
<pre class="syntax ">(?id:string, ?reopen:bool, string)-&gt;source</pre>
<p>
WARNING: This is only EXPERIMENTAL!
</p>
<p>
Get a stream from a pipe using marshaling.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>reopen</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Try to reopen the pipe after a failure.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Pipe to get the stream from.</li>
</ul>
<h5>input.mplayer</h5>
<pre class="syntax ">(?id:string, ?restart:bool, ?restart_on_error:bool,
 ?buffer:float, ?max:float, string)-&gt;source</pre>
<p>
Stream data from mplayer
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;input.mplayer&quot;</code>)</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>true</code>): restart on exit.</li>
<li>
<code>restart_on_error</code> (<code>bool</code> &ndash; defaults to <code>false</code>): restart on exit with error.</li>
<li>
<code>buffer</code> (<code>float</code> &ndash; defaults to <code>0.2</code>): Duration of the pre-buffered data.</li>
<li>
<code>max</code> (<code>float</code> &ndash; defaults to <code>10.</code>): Maximum duration of the buffered data.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): data URI.</li>
</ul>
<h5>input.oss</h5>
<pre class="syntax ">(?id:string, ?device:string)-&gt;source</pre>
<p>
Stream from an OSS input device.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>device</code> (<code>string</code> &ndash; defaults to <code>&quot;/dev/dsp&quot;</code>): OSS device to use.</li>
</ul>
<h5>input.portaudio</h5>
<pre class="syntax ">(?id:string, ?buflen:int)-&gt;source</pre>
<p>
Stream from a portaudio input device.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>buflen</code> (<code>int</code> &ndash; defaults to <code>256</code>): Length of a buffer in samples.</li>
</ul>
<h5>input.pulseaudio</h5>
<pre class="syntax ">(?id:string, ?client:string, ?device:string)
 -&gt;source</pre>
<p>
Stream from a portaudio input device.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>client</code> (<code>string</code> &ndash; defaults to <code>&quot;liquidsoap&quot;</code>)</li>
<li>
<code>device</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Device to use. Uses default if set to “”.</li>
</ul>
<h5>input.v4l</h5>
<pre class="syntax ">(?id:string, ?device:string)-&gt;source</pre>
<p>
Stream from a V4L (= video 4 linux) input device, such as a webcam.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>device</code> (<code>string</code> &ndash; defaults to <code>&quot;/dev/video0&quot;</code>): V4L device to use.</li>
</ul>
<h5>mksafe</h5>
<pre class="syntax ">(source)-&gt;source</pre>
<p>
Turn a source into an infaillible source.
by adding blank when the source is not available.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>source</code>): the source to turn infaillible</li>
</ul>
<h5>noise</h5>
<pre class="syntax ">(?id:string, ?duration:float)-&gt;source</pre>
<p>
Generate white noise.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>0.</code>)</li>
</ul>
<h5>playlist</h5>
<pre class="syntax ">(?id:string, ?length:float, ?default_duration:float,
 ?conservative:bool, ?timeout:float, ?mode:string,
 ?reload:int, ?reload_mode:string,
 ?mime_type:string, ?prefix:string, ?timeout:float,
 string)-&gt;source</pre>
<p>
Loop on a playlist of URIs.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>length</code> (<code>float</code> &ndash; defaults to <code>10.</code>): How much audio (in sec.) should be queued in advance.</li>
<li>
<code>default_duration</code> (<code>float</code> &ndash; defaults to <code>30.</code>): When unknown, assume this duration (in sec.) for files.</li>
<li>
<code>conservative</code> (<code>bool</code> &ndash; defaults to <code>false</code>): If true, estimated remaining time on the current track is not considered when computing queue length.</li>
<li>
<code>timeout</code> (<code>float</code> &ndash; defaults to <code>20.</code>): Timeout (in sec.) for a single download.</li>
<li>
<code>mode</code> (<code>string</code> &ndash; defaults to <code>&quot;randomize&quot;</code>): Play the files in the playlist either in the order (“normal” mode), or shuffle the playlist each time it is loaded, and play it in this order for a whole round (“randomize” mode), or pick a random file in the playlist each time (“random” mode).</li>
<li>
<code>reload</code> (<code>int</code> &ndash; defaults to <code>0</code>): Amount of time (in seconds or rounds) before which the playlist is reloaded; 0 means never.</li>
<li>
<code>reload_mode</code> (<code>string</code> &ndash; defaults to <code>&quot;seconds&quot;</code>): Unit of the reload parameter, either 'rounds' or 'seconds'.</li>
<li>
<code>mime_type</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Default MIME type for the playlist. Empty string means automatic detection.</li>
<li>
<code>prefix</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Add a constant prefix to all requests. Usefull for passing extra information using annotate, or for resolution through a particular protocol, such as replaygain.</li>
<li>
<code>timeout</code> (<code>float</code> &ndash; defaults to <code>20.</code>): Timeout (in seconds) for a single download.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): URI where to find the playlist.</li>
</ul>
<h5>playlist.once</h5>
<pre class="syntax ">(?random:bool, ?on_done:(()-&gt;unit), string)-&gt;source</pre>
<p>
Custom playlist source written using the script language.
Will read directory or playlist, play all files and stop
</p>
<ul>
<li>
<code>random</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Randomize playlist content</li>
<li>
<code>on_done</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Function to execute when the playlist is finished</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Playlist URI</li>
</ul>
<h5>playlist.safe</h5>
<pre class="syntax ">(?id:string, ?mode:string, ?reload:int,
 ?reload_mode:string, ?mime_type:string,
 ?prefix:string, ?timeout:float, string)-&gt;source</pre>
<p>
Loop on a playlist of local files, and never fail. In order to do so, it has to check every file at the loading, so the streamer startup may take a few seconds. To avoid this, use a standard playlist, and put only a few local files in a default safe_playlist in order to ensure the liveness of the streamer.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>mode</code> (<code>string</code> &ndash; defaults to <code>&quot;randomize&quot;</code>): Play the files in the playlist either in the order (“normal” mode), or shuffle the playlist each time it is loaded, and play it in this order for a whole round (“randomize” mode), or pick a random file in the playlist each time (“random” mode).</li>
<li>
<code>reload</code> (<code>int</code> &ndash; defaults to <code>0</code>): Amount of time (in seconds or rounds) before which the playlist is reloaded; 0 means never.</li>
<li>
<code>reload_mode</code> (<code>string</code> &ndash; defaults to <code>&quot;seconds&quot;</code>): Unit of the reload parameter, either 'rounds' or 'seconds'.</li>
<li>
<code>mime_type</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Default MIME type for the playlist. Empty string means automatic detection.</li>
<li>
<code>prefix</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Add a constant prefix to all requests. Usefull for passing extra information using annotate, or for resolution through a particular protocol, such as replaygain.</li>
<li>
<code>timeout</code> (<code>float</code> &ndash; defaults to <code>20.</code>): Timeout (in seconds) for a single download.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): URI where to find the playlist.</li>
</ul>
<h5>request.dynamic</h5>
<pre class="syntax ">(?id:string, (()-&gt;request), ?length:float,
 ?default_duration:float, ?conservative:bool,
 ?timeout:float)-&gt;source</pre>
<p>
Play request dynamically created by a given function.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>()-&gt;request</code>): A function generating requests: an initial URI (possibly fake) together with an initial list of alternative indicators.</li>
<li>
<code>length</code> (<code>float</code> &ndash; defaults to <code>10.</code>): How much audio (in sec.) should be queued in advance.</li>
<li>
<code>default_duration</code> (<code>float</code> &ndash; defaults to <code>30.</code>): When unknown, assume this duration (in sec.) for files.</li>
<li>
<code>conservative</code> (<code>bool</code> &ndash; defaults to <code>false</code>): If true, estimated remaining time on the current track is not considered when computing queue length.</li>
<li>
<code>timeout</code> (<code>float</code> &ndash; defaults to <code>20.</code>): Timeout (in sec.) for a single download.</li>
</ul>
<h5>request.equeue</h5>
<pre class="syntax ">(?id:string, ?length:float, ?default_duration:float,
 ?conservative:bool, ?timeout:float)-&gt;source</pre>
<p>
Receive URIs from users, and play them. Insertion and deletion possible at any position.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>length</code> (<code>float</code> &ndash; defaults to <code>10.</code>): How much audio (in sec.) should be queued in advance.</li>
<li>
<code>default_duration</code> (<code>float</code> &ndash; defaults to <code>30.</code>): When unknown, assume this duration (in sec.) for files.</li>
<li>
<code>conservative</code> (<code>bool</code> &ndash; defaults to <code>false</code>): If true, estimated remaining time on the current track is not considered when computing queue length.</li>
<li>
<code>timeout</code> (<code>float</code> &ndash; defaults to <code>20.</code>): Timeout (in sec.) for a single download.</li>
</ul>
<h5>request.queue</h5>
<pre class="syntax ">(?id:string, ?queue:[request], ?interactive:bool,
 ?length:float, ?default_duration:float,
 ?conservative:bool, ?timeout:float)-&gt;source</pre>
<p>
Receive URIs from users, and play them.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>queue</code> (<code>[request]</code> &ndash; defaults to <code>[  ]</code>): Initial queue of requests.</li>
<li>
<code>interactive</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Should the queue be controllable via telnet?</li>
<li>
<code>length</code> (<code>float</code> &ndash; defaults to <code>10.</code>): How much audio (in sec.) should be queued in advance.</li>
<li>
<code>default_duration</code> (<code>float</code> &ndash; defaults to <code>30.</code>): When unknown, assume this duration (in sec.) for files.</li>
<li>
<code>conservative</code> (<code>bool</code> &ndash; defaults to <code>false</code>): If true, estimated remaining time on the current track is not considered when computing queue length.</li>
<li>
<code>timeout</code> (<code>float</code> &ndash; defaults to <code>20.</code>): Timeout (in sec.) for a single download.</li>
</ul>
<h5>saw</h5>
<pre class="syntax ">(?id:string, ?duration:float, ?float)-&gt;source</pre>
<p>
Generate a saw wave.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>0.</code>)</li>
<li>
<code>(unlabeled)</code> (<code>float</code> &ndash; defaults to <code>440.</code>): Frequency of the saw.</li>
</ul>
<h5>sine</h5>
<pre class="syntax ">(?id:string, ?duration:float, ?float)-&gt;source</pre>
<p>
Generate a sine wave.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>0.</code>)</li>
<li>
<code>(unlabeled)</code> (<code>float</code> &ndash; defaults to <code>440.</code>): Frequency of the sine.</li>
</ul>
<h5>single</h5>
<pre class="syntax ">(?id:string, string, ?length:float,
 ?default_duration:float, ?conservative:bool,
 ?timeout:float)-&gt;source</pre>
<p>
Loop on a request. It never fails if the request is static, meaning that it can be fetched once. Typically, http, ftp, say requests are static, and time is not.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): URI where to find the file</li>
<li>
<code>length</code> (<code>float</code> &ndash; defaults to <code>10.</code>): How much audio (in sec.) should be queued in advance.</li>
<li>
<code>default_duration</code> (<code>float</code> &ndash; defaults to <code>30.</code>): When unknown, assume this duration (in sec.) for files.</li>
<li>
<code>conservative</code> (<code>bool</code> &ndash; defaults to <code>false</code>): If true, estimated remaining time on the current track is not considered when computing queue length.</li>
<li>
<code>timeout</code> (<code>float</code> &ndash; defaults to <code>20.</code>): Timeout (in sec.) for a single download.</li>
</ul>
<h5>square</h5>
<pre class="syntax ">(?id:string, ?duration:float, ?float)-&gt;source</pre>
<p>
Generate a square wave.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>0.</code>)</li>
<li>
<code>(unlabeled)</code> (<code>float</code> &ndash; defaults to <code>440.</code>): Frequency of the square.</li>
</ul>
<h5>video.image</h5>
<pre class="syntax ">(?id:string, ?width:int, ?height:int, ?x:int,
 ?y:int, ?alpha:int, ?duration:float, string)
 -&gt;source</pre>
<p>
Display a static image.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>width</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Scale to width (negative means original width).</li>
<li>
<code>height</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Scale to width (negative means original height).</li>
<li>
<code>x</code> (<code>int</code> &ndash; defaults to <code>0</code>): x position (negative means from right).</li>
<li>
<code>y</code> (<code>int</code> &ndash; defaults to <code>0</code>): y position (negative means from bottom).</li>
<li>
<code>alpha</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Color to convert to alpha (in 0xRRGGBB format, negative means no alpha).</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>0.</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Path to image file.</li>
</ul>
<h5>video.noise</h5>
<pre class="syntax ">(?id:string, ?duration:float)-&gt;source</pre>
<p>
Generate white noise.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>0.</code>)</li>
</ul>
<h3><a name="SourceMIDIProcessing">Source / MIDI Processing</a></h3>
<h5>midi.merge_all</h5>
<pre class="syntax ">(?id:string, ?track_out:int, source)-&gt;source</pre>
<p>
Merge all MIDI tracks in one.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>track_out</code> (<code>int</code> &ndash; defaults to <code>0</code>): Destination track.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>midi.remove</h5>
<pre class="syntax ">(?id:string, [int], source)-&gt;source</pre>
<p>
Remove MIDI tracks.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>[int]</code>): Tracks to remove.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h3><a name="SourceOutput">Source / Output</a></h3>
<h5>out</h5>
<pre class="syntax ">(source)-&gt;source</pre>
<p>
Output a stream using the 'output.prefered' operator. The input source does
not need to be infallible, blank will just be played during failures.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>source</code>): the source to output</li>
</ul>
<h5>output.alsa</h5>
<pre class="syntax ">(?id:string, ?bufferize:bool, ?device:string,
 source)-&gt;source</pre>
<p>
Output the source's stream to an ALSA output device.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>bufferize</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Bufferize output</li>
<li>
<code>device</code> (<code>string</code> &ndash; defaults to <code>&quot;default&quot;</code>): Alsa device to use</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.ao</h5>
<pre class="syntax ">(?id:string, ?fallible:bool, ?on_start:(()-&gt;unit),
 ?on_stop:(()-&gt;unit), ?start:bool, ?driver:string,
 ?buffer_size:int, ?options:[(string*string)],
 source)-&gt;source</pre>
<p>
Output stream to local sound card using libao.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>driver</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): libao driver to use.</li>
<li>
<code>buffer_size</code> (<code>int</code> &ndash; defaults to <code>2</code>): Set buffer size, in frames.</li>
<li>
<code>options</code> (<code>[(string*string)]</code> &ndash; defaults to <code>[  ]</code>): List of parameters, depends on driver.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.aplay</h5>
<pre class="syntax ">(?id:string, ?device:string, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?restart_on_crash:bool, source)-&gt;source</pre>
<p>
Output the stream using aplay.
Using this turns “root.sync” to false
since aplay will do the synchronisation
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;output.aplay&quot;</code>): Output's ID</li>
<li>
<code>device</code> (<code>string</code> &ndash; defaults to <code>&quot;default&quot;</code>): Alsa pcm device name</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>restart_on_crash</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart external process on crash. If false, liquidsoap will stop.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>): Source to play</li>
</ul>
<h5>output.dummy</h5>
<pre class="syntax ">(?id:string, ?fallible:bool, ?autostart:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit), source)
 -&gt;source</pre>
<p>
Dummy output for debugging purposes.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>)</li>
<li>
<code>autostart</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>)</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>)</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.file.aac</h5>
<pre class="syntax ">(?id:string, ?fallible:bool, ?on_start:(()-&gt;unit),
 ?on_stop:(()-&gt;unit), ?start:bool, ?bandwidth:int,
 ?bitrate:int, ?quality:int, string, source)
 -&gt;source</pre>
<p>
Output the source's stream as an AAC file.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>bandwidth</code> (<code>int</code> &ndash; defaults to <code>16000</code>)</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>128</code>)</li>
<li>
<code>quality</code> (<code>int</code> &ndash; defaults to <code>100</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Filename where to output the AAC stream.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.file.aacplus</h5>
<pre class="syntax ">(?id:string, ?samplerate:int, ?bitrate:int,
 ?append:bool, ?perm:int, ?dir_perm:int,
 ?reopen_delay:float, ?reopen_on_metadata:bool,
 ?reopen_when:(()-&gt;bool), string, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?start:bool, source)-&gt;source</pre>
<p>
Output the source's stream as an AAC+ file.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>)</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>64</code>)</li>
<li>
<code>append</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Do not truncate but append in the file if it exists.</li>
<li>
<code>perm</code> (<code>int</code> &ndash; defaults to <code>438</code>): Permission of the file if it has to be created, up to umask. You can and should write this number in octal notation: 0oXXX. The default value is however displayed in decimal (0o666 = 6*8^2 + 6*8 + 6 = 438).</li>
<li>
<code>dir_perm</code> (<code>int</code> &ndash; defaults to <code>511</code>): Permission of the directories if some have to be created, up to umask. Although you can enter values in octal notation (0oXXX) they will be displayed in decimal (for instance, 0o777 = 7*8^2 + 7*8 + 7 = 511).</li>
<li>
<code>reopen_delay</code> (<code>float</code> &ndash; defaults to <code>120.</code>): Prevent re-opening of the file within that delay, in seconds.</li>
<li>
<code>reopen_on_metadata</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Re-open on every new metadata information.</li>
<li>
<code>reopen_when</code> (<code>()-&gt;bool</code> &ndash; defaults to <code>{false}</code>): When should the output file be re-opened.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Filename where to output the stream. Some strftime conversion specifiers are available: <code>%SMHdmY</code>. You can also use <code>$(..)</code> interpolation notation for metadata.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.file.dirac</h5>
<pre class="syntax ">(?id:string, ?quality:int, ?vorbis_quality:float,
 ?skeleton:bool, ?append:bool, ?perm:int,
 ?dir_perm:int, ?reopen_delay:float,
 ?reopen_on_metadata:bool, ?reopen_when:(()-&gt;bool),
 string, ?fallible:bool, ?on_start:(()-&gt;unit),
 ?on_stop:(()-&gt;unit), ?start:bool, source)-&gt;source</pre>
<p>
Output the source's stream as an ogg/theora file.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>quality</code> (<code>int</code> &ndash; defaults to <code>100</code>): Quality setting for dirac encoding.</li>
<li>
<code>vorbis_quality</code> (<code>float</code> &ndash; defaults to <code>2.</code>): Quality setting for vorbis encoding. Don't encode audio if value is negative or null.</li>
<li>
<code>skeleton</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Add an ogg skeleton to the stream. Recommended for theora only.</li>
<li>
<code>append</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Do not truncate but append in the file if it exists.</li>
<li>
<code>perm</code> (<code>int</code> &ndash; defaults to <code>438</code>): Permission of the file if it has to be created, up to umask. You can and should write this number in octal notation: 0oXXX. The default value is however displayed in decimal (0o666 = 6*8^2 + 6*8 + 6 = 438).</li>
<li>
<code>dir_perm</code> (<code>int</code> &ndash; defaults to <code>511</code>): Permission of the directories if some have to be created, up to umask. Although you can enter values in octal notation (0oXXX) they will be displayed in decimal (for instance, 0o777 = 7*8^2 + 7*8 + 7 = 511).</li>
<li>
<code>reopen_delay</code> (<code>float</code> &ndash; defaults to <code>120.</code>): Prevent re-opening of the file within that delay, in seconds.</li>
<li>
<code>reopen_on_metadata</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Re-open on every new metadata information.</li>
<li>
<code>reopen_when</code> (<code>()-&gt;bool</code> &ndash; defaults to <code>{false}</code>): When should the output file be re-opened.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Filename where to output the stream. Some strftime conversion specifiers are available: <code>%SMHdmY</code>. You can also use <code>$(..)</code> interpolation notation for metadata.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.file.external</h5>
<pre class="syntax ">(?id:string, ~process:(([(string*string)])-&gt;string),
 ?samplerate:int, ?header:bool,
 ?restart_on_crash:bool, ?restart_on_new_track:bool,
 ?restart_encoder_delay:int, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?start:bool, ?append:bool, ?perm:int,
 ?dir_perm:int, ?reopen_delay:float,
 ?reopen_on_metadata:bool, ?reopen_when:(()-&gt;bool),
 string, source)-&gt;source</pre>
<p>
Output the source's stream as a file, using an external encoding process.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>process</code> (<code>([(string*string)])-&gt;string</code>): External encoding process. Takes initial metadata and return the command to start.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>): Output sample rate.</li>
<li>
<code>header</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Write wav header at beginning of encoded input.</li>
<li>
<code>restart_on_crash</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart external process when it crashed. If false, liquidsoap exits.</li>
<li>
<code>restart_on_new_track</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart encoder on new track.</li>
<li>
<code>restart_encoder_delay</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Restart the encoder after this delay, in seconds.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>append</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Do not truncate but append in the file if it exists.</li>
<li>
<code>perm</code> (<code>int</code> &ndash; defaults to <code>438</code>): Permission of the file if it has to be created, up to umask. You can and should write this number in octal notation: 0oXXX. The default value is however displayed in decimal (0o666 = 6*8^2 + 6*8 + 6 = 438).</li>
<li>
<code>dir_perm</code> (<code>int</code> &ndash; defaults to <code>511</code>): Permission of the directories if some have to be created, up to umask. Although you can enter values in octal notation (0oXXX) they will be displayed in decimal (for instance, 0o777 = 7*8^2 + 7*8 + 7 = 511).</li>
<li>
<code>reopen_delay</code> (<code>float</code> &ndash; defaults to <code>120.</code>): Prevent re-opening of the file within that delay, in seconds.</li>
<li>
<code>reopen_on_metadata</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Re-open on every new metadata information.</li>
<li>
<code>reopen_when</code> (<code>()-&gt;bool</code> &ndash; defaults to <code>{false}</code>): When should the output file be re-opened.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Filename where to output the stream. Some strftime conversion specifiers are available: <code>%SMHdmY</code>. You can also use <code>$(..)</code> interpolation notation for metadata.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.file.mp3</h5>
<pre class="syntax ">(?id:string, ?samplerate:int, ?bitrate:int,
 ?quality:int, ?stereo:bool, ?append:bool,
 ?perm:int, ?dir_perm:int, ?reopen_delay:float,
 ?reopen_on_metadata:bool, ?reopen_when:(()-&gt;bool),
 string, ?fallible:bool, ?on_start:(()-&gt;unit),
 ?on_stop:(()-&gt;unit), ?start:bool, source)-&gt;source</pre>
<p>
Output the source's stream as an MP3 file.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>)</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>128</code>)</li>
<li>
<code>quality</code> (<code>int</code> &ndash; defaults to <code>5</code>)</li>
<li>
<code>stereo</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>append</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Do not truncate but append in the file if it exists.</li>
<li>
<code>perm</code> (<code>int</code> &ndash; defaults to <code>438</code>): Permission of the file if it has to be created, up to umask. You can and should write this number in octal notation: 0oXXX. The default value is however displayed in decimal (0o666 = 6*8^2 + 6*8 + 6 = 438).</li>
<li>
<code>dir_perm</code> (<code>int</code> &ndash; defaults to <code>511</code>): Permission of the directories if some have to be created, up to umask. Although you can enter values in octal notation (0oXXX) they will be displayed in decimal (for instance, 0o777 = 7*8^2 + 7*8 + 7 = 511).</li>
<li>
<code>reopen_delay</code> (<code>float</code> &ndash; defaults to <code>120.</code>): Prevent re-opening of the file within that delay, in seconds.</li>
<li>
<code>reopen_on_metadata</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Re-open on every new metadata information.</li>
<li>
<code>reopen_when</code> (<code>()-&gt;bool</code> &ndash; defaults to <code>{false}</code>): When should the output file be re-opened.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Filename where to output the stream. Some strftime conversion specifiers are available: <code>%SMHdmY</code>. You can also use <code>$(..)</code> interpolation notation for metadata.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.file.speex</h5>
<pre class="syntax ">(?id:string, ?samplerate:int, ?bitrate:int,
 ?quality:int, ?mode:string, ?stereo:bool,
 ?vbr:bool, ?frames_per_packet:int, ?complexity:int,
 ?abr:int, ?skeleton:bool, ?append:bool, ?perm:int,
 ?dir_perm:int, ?reopen_delay:float,
 ?reopen_on_metadata:bool, ?reopen_when:(()-&gt;bool),
 string, ?fallible:bool, ?on_start:(()-&gt;unit),
 ?on_stop:(()-&gt;unit), ?start:bool, source)-&gt;source</pre>
<p>
Output the source stream as an Ogg speex file.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Output sample rate. Use liquidsoap's default if &lt;= 0.</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Target bitrate (in kbps). Not used if &lt;= 0.</li>
<li>
<code>quality</code> (<code>int</code> &ndash; defaults to <code>7</code>): Target quality (0 to 10). Not used if &lt;= 0.</li>
<li>
<code>mode</code> (<code>string</code> &ndash; defaults to <code>&quot;narrowband&quot;</code>): Encoding mode, one of “narrowband”, “wideband” or “ultra-wideband”.</li>
<li>
<code>stereo</code> (<code>bool</code> &ndash; defaults to <code>false</code>)</li>
<li>
<code>vbr</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Encode in vbr mode.</li>
<li>
<code>frames_per_packet</code> (<code>int</code> &ndash; defaults to <code>1</code>): Number of frame per Ogg packet (1 to 10).</li>
<li>
<code>complexity</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Encoding complexity (0-10). Not used if &lt;= 0.</li>
<li>
<code>abr</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Set average bitrate. Not used if &lt;= 0.</li>
<li>
<code>skeleton</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Add an ogg skeleton to the stream. Recommended for theora only.</li>
<li>
<code>append</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Do not truncate but append in the file if it exists.</li>
<li>
<code>perm</code> (<code>int</code> &ndash; defaults to <code>438</code>): Permission of the file if it has to be created, up to umask. You can and should write this number in octal notation: 0oXXX. The default value is however displayed in decimal (0o666 = 6*8^2 + 6*8 + 6 = 438).</li>
<li>
<code>dir_perm</code> (<code>int</code> &ndash; defaults to <code>511</code>): Permission of the directories if some have to be created, up to umask. Although you can enter values in octal notation (0oXXX) they will be displayed in decimal (for instance, 0o777 = 7*8^2 + 7*8 + 7 = 511).</li>
<li>
<code>reopen_delay</code> (<code>float</code> &ndash; defaults to <code>120.</code>): Prevent re-opening of the file within that delay, in seconds.</li>
<li>
<code>reopen_on_metadata</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Re-open on every new metadata information.</li>
<li>
<code>reopen_when</code> (<code>()-&gt;bool</code> &ndash; defaults to <code>{false}</code>): When should the output file be re-opened.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Filename where to output the stream. Some strftime conversion specifiers are available: <code>%SMHdmY</code>. You can also use <code>$(..)</code> interpolation notation for metadata.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.file.theora</h5>
<pre class="syntax ">(?id:string, ?quality:int, ?vorbis_quality:float,
 ?skeleton:bool, ?append:bool, ?perm:int,
 ?dir_perm:int, ?reopen_delay:float,
 ?reopen_on_metadata:bool, ?reopen_when:(()-&gt;bool),
 string, ?fallible:bool, ?on_start:(()-&gt;unit),
 ?on_stop:(()-&gt;unit), ?start:bool, source)-&gt;source</pre>
<p>
Output the source's stream as an ogg/theora file.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>quality</code> (<code>int</code> &ndash; defaults to <code>100</code>): Quality setting for theora encoding.</li>
<li>
<code>vorbis_quality</code> (<code>float</code> &ndash; defaults to <code>2.</code>): Quality setting for vorbis encoding. Don't encode audio if value is negative or null.</li>
<li>
<code>skeleton</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Add an ogg skeleton to the stream. Recommended for theora only.</li>
<li>
<code>append</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Do not truncate but append in the file if it exists.</li>
<li>
<code>perm</code> (<code>int</code> &ndash; defaults to <code>438</code>): Permission of the file if it has to be created, up to umask. You can and should write this number in octal notation: 0oXXX. The default value is however displayed in decimal (0o666 = 6*8^2 + 6*8 + 6 = 438).</li>
<li>
<code>dir_perm</code> (<code>int</code> &ndash; defaults to <code>511</code>): Permission of the directories if some have to be created, up to umask. Although you can enter values in octal notation (0oXXX) they will be displayed in decimal (for instance, 0o777 = 7*8^2 + 7*8 + 7 = 511).</li>
<li>
<code>reopen_delay</code> (<code>float</code> &ndash; defaults to <code>120.</code>): Prevent re-opening of the file within that delay, in seconds.</li>
<li>
<code>reopen_on_metadata</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Re-open on every new metadata information.</li>
<li>
<code>reopen_when</code> (<code>()-&gt;bool</code> &ndash; defaults to <code>{false}</code>): When should the output file be re-opened.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Filename where to output the stream. Some strftime conversion specifiers are available: <code>%SMHdmY</code>. You can also use <code>$(..)</code> interpolation notation for metadata.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.file.vorbis</h5>
<pre class="syntax ">(?id:string, ?samplerate:int, ?stereo:bool,
 ?skeleton:bool, ?start:bool, ?quality:float,
 ?append:bool, ?perm:int, ?dir_perm:int,
 ?reopen_delay:float, ?reopen_on_metadata:bool,
 ?reopen_when:(()-&gt;bool), string, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?start:bool, source)-&gt;source</pre>
<p>
Output the source stream as an Ogg Vorbis file in Variable BitRate mode.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>)</li>
<li>
<code>stereo</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>skeleton</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Add an ogg skeleton to the stream. Recommended for theora only.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Start output on operator initialization.</li>
<li>
<code>quality</code> (<code>float</code> &ndash; defaults to <code>2.</code>): Desired quality level, currently from -1. to 10. (low to high).</li>
<li>
<code>append</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Do not truncate but append in the file if it exists.</li>
<li>
<code>perm</code> (<code>int</code> &ndash; defaults to <code>438</code>): Permission of the file if it has to be created, up to umask. You can and should write this number in octal notation: 0oXXX. The default value is however displayed in decimal (0o666 = 6*8^2 + 6*8 + 6 = 438).</li>
<li>
<code>dir_perm</code> (<code>int</code> &ndash; defaults to <code>511</code>): Permission of the directories if some have to be created, up to umask. Although you can enter values in octal notation (0oXXX) they will be displayed in decimal (for instance, 0o777 = 7*8^2 + 7*8 + 7 = 511).</li>
<li>
<code>reopen_delay</code> (<code>float</code> &ndash; defaults to <code>120.</code>): Prevent re-opening of the file within that delay, in seconds.</li>
<li>
<code>reopen_on_metadata</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Re-open on every new metadata information.</li>
<li>
<code>reopen_when</code> (<code>()-&gt;bool</code> &ndash; defaults to <code>{false}</code>): When should the output file be re-opened.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Filename where to output the stream. Some strftime conversion specifiers are available: <code>%SMHdmY</code>. You can also use <code>$(..)</code> interpolation notation for metadata.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.file.vorbis.abr</h5>
<pre class="syntax ">(?id:string, ?samplerate:int, ?stereo:bool,
 ?skeleton:bool, ?append:bool, ?perm:int,
 ?dir_perm:int, ?reopen_delay:float,
 ?reopen_on_metadata:bool, ?reopen_when:(()-&gt;bool),
 string, ?fallible:bool, ?on_start:(()-&gt;unit),
 ?on_stop:(()-&gt;unit), ?start:bool, ?bitrate:int,
 ?min_bitrate:int, ?max_bitrate:int, source)
 -&gt;source</pre>
<p>
Output the source stream as an Ogg Vorbis file in Average BitRate mode.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>)</li>
<li>
<code>stereo</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>skeleton</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Add an ogg skeleton to the stream. Recommended for theora only.</li>
<li>
<code>append</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Do not truncate but append in the file if it exists.</li>
<li>
<code>perm</code> (<code>int</code> &ndash; defaults to <code>438</code>): Permission of the file if it has to be created, up to umask. You can and should write this number in octal notation: 0oXXX. The default value is however displayed in decimal (0o666 = 6*8^2 + 6*8 + 6 = 438).</li>
<li>
<code>dir_perm</code> (<code>int</code> &ndash; defaults to <code>511</code>): Permission of the directories if some have to be created, up to umask. Although you can enter values in octal notation (0oXXX) they will be displayed in decimal (for instance, 0o777 = 7*8^2 + 7*8 + 7 = 511).</li>
<li>
<code>reopen_delay</code> (<code>float</code> &ndash; defaults to <code>120.</code>): Prevent re-opening of the file within that delay, in seconds.</li>
<li>
<code>reopen_on_metadata</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Re-open on every new metadata information.</li>
<li>
<code>reopen_when</code> (<code>()-&gt;bool</code> &ndash; defaults to <code>{false}</code>): When should the output file be re-opened.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Filename where to output the stream. Some strftime conversion specifiers are available: <code>%SMHdmY</code>. You can also use <code>$(..)</code> interpolation notation for metadata.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>128</code>): Target bitrate (in kbps).</li>
<li>
<code>min_bitrate</code> (<code>int</code> &ndash; defaults to <code>118</code>): Minimum bitrate (in kbps).</li>
<li>
<code>max_bitrate</code> (<code>int</code> &ndash; defaults to <code>138</code>): Maximum bitrate (in kbps).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.file.vorbis.cbr</h5>
<pre class="syntax ">(?id:string, ?samplerate:int, ?stereo:bool,
 ?skeleton:bool, ?start:bool, ?bitrate:int,
 ?append:bool, ?perm:int, ?dir_perm:int,
 ?reopen_delay:float, ?reopen_on_metadata:bool,
 ?reopen_when:(()-&gt;bool), string, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?start:bool, source)-&gt;source</pre>
<p>
Output the source stream as an Ogg Vorbis file in Constant BitRate mode.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>)</li>
<li>
<code>stereo</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>skeleton</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Add an ogg skeleton to the stream. Recommended for theora only.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Start output on operator initialization.</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>128</code>): Bitrate (in kbps).</li>
<li>
<code>append</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Do not truncate but append in the file if it exists.</li>
<li>
<code>perm</code> (<code>int</code> &ndash; defaults to <code>438</code>): Permission of the file if it has to be created, up to umask. You can and should write this number in octal notation: 0oXXX. The default value is however displayed in decimal (0o666 = 6*8^2 + 6*8 + 6 = 438).</li>
<li>
<code>dir_perm</code> (<code>int</code> &ndash; defaults to <code>511</code>): Permission of the directories if some have to be created, up to umask. Although you can enter values in octal notation (0oXXX) they will be displayed in decimal (for instance, 0o777 = 7*8^2 + 7*8 + 7 = 511).</li>
<li>
<code>reopen_delay</code> (<code>float</code> &ndash; defaults to <code>120.</code>): Prevent re-opening of the file within that delay, in seconds.</li>
<li>
<code>reopen_on_metadata</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Re-open on every new metadata information.</li>
<li>
<code>reopen_when</code> (<code>()-&gt;bool</code> &ndash; defaults to <code>{false}</code>): When should the output file be re-opened.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Filename where to output the stream. Some strftime conversion specifiers are available: <code>%SMHdmY</code>. You can also use <code>$(..)</code> interpolation notation for metadata.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.file.wav</h5>
<pre class="syntax ">(?id:string, ?append:bool, ?perm:int, ?dir_perm:int,
 ?reopen_delay:float, ?reopen_on_metadata:bool,
 ?reopen_when:(()-&gt;bool), string, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?start:bool, source)-&gt;source</pre>
<p>
Output the source's stream to a WAV file.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>append</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Do not truncate but append in the file if it exists.</li>
<li>
<code>perm</code> (<code>int</code> &ndash; defaults to <code>438</code>): Permission of the file if it has to be created, up to umask. You can and should write this number in octal notation: 0oXXX. The default value is however displayed in decimal (0o666 = 6*8^2 + 6*8 + 6 = 438).</li>
<li>
<code>dir_perm</code> (<code>int</code> &ndash; defaults to <code>511</code>): Permission of the directories if some have to be created, up to umask. Although you can enter values in octal notation (0oXXX) they will be displayed in decimal (for instance, 0o777 = 7*8^2 + 7*8 + 7 = 511).</li>
<li>
<code>reopen_delay</code> (<code>float</code> &ndash; defaults to <code>120.</code>): Prevent re-opening of the file within that delay, in seconds.</li>
<li>
<code>reopen_on_metadata</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Re-open on every new metadata information.</li>
<li>
<code>reopen_when</code> (<code>()-&gt;bool</code> &ndash; defaults to <code>{false}</code>): When should the output file be re-opened.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Filename where to output the stream. Some strftime conversion specifiers are available: <code>%SMHdmY</code>. You can also use <code>$(..)</code> interpolation notation for metadata.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.icecast.aacplus</h5>
<pre class="syntax ">(?id:string, ?restart:bool, ?restart_delay:int,
 ?mount:string, ?name:string, ?protocol:string,
 ?host:string, ?port:int, ?user:string,
 ?password:string, ?genre:string, ?url:string,
 ?description:string, ?public:bool,
 ?headers:[(string*string)], ?format:string,
 ?dumpfile:string, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?start:bool, ?samplerate:int, ?bitrate:int, source)
 -&gt;source</pre>
<p>
Output the source's stream to an icecast2-compatible server in AAC+ format.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>mount</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [name]&quot;</code>)</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>protocol</code> (<code>string</code> &ndash; defaults to <code>&quot;http&quot;</code>): Protocol of the streaming server: 'http' for Icecast, 'icy' for shoutcast.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>headers</code> (<code>[(string*string)]</code> &ndash; defaults to <code>[  ]</code>): Additional headers.</li>
<li>
<code>format</code> (<code>string</code> &ndash; defaults to <code>&quot;audio/aacp&quot;</code>): Content-type (mime) for the format. “mp3” is a short-hand for mpeg audio, “ogg” for ogg data.</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>)</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>64</code>)</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.icecast.aacplusenc</h5>
<pre class="syntax ">(?id:string, ?start:bool, ?restart:bool,
 ?restart_delay:int, ?host:string, ?port:int,
 ?user:string, ?password:string, ?genre:string,
 ?url:string, ?description:string, ?public:bool,
 ?dumpfile:string, ?mount:string, ?name:string,
 ?protocol:string, ?aacplusenc:string, ?bitrate:int,
 ?fallible:bool, ?on_start:(()-&gt;unit),
 ?on_stop:(()-&gt;unit), ?restart_on_crash:bool,
 ?restart_on_new_track:bool,
 ?restart_encoder_delay:int,
 ?headers:[(string*string)], source)-&gt;source</pre>
<p>
Output to icecast using the aacplusenc command line encoder.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;output.icecast.aacplusenc&quot;</code>): Output's ID</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Start output threads on operator initialization.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net/&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>mount</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [name]&quot;</code>)</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>protocol</code> (<code>string</code> &ndash; defaults to <code>&quot;http&quot;</code>): Protocol of the streaming server: 'http' for Icecast, 'icy' for Shoutcast.</li>
<li>
<code>aacplusenc</code> (<code>string</code> &ndash; defaults to <code>&quot;aacplusenc&quot;</code>): The aacplusenc binary</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>64</code>): Encoder bitrate</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>restart_on_crash</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart external process on crash. If false, liquidsoap will stop.</li>
<li>
<code>restart_on_new_track</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart encoder upon new track.</li>
<li>
<code>restart_encoder_delay</code> (<code>int</code> &ndash; defaults to <code>3600</code>): Restart the encoder after this delay, in seconds.</li>
<li>
<code>headers</code> (<code>[(string*string)]</code> &ndash; defaults to <code>[  ]</code>)</li>
<li>
<code>(unlabeled)</code> (<code>source</code>): The source to output</li>
</ul>
<h5>output.icecast.external</h5>
<pre class="syntax ">(?id:string, ?restart:bool, ?restart_delay:int,
 ?mount:string, ?name:string, ?protocol:string,
 ?host:string, ?port:int, ?user:string,
 ?password:string, ?genre:string, ?url:string,
 ?description:string, ?public:bool,
 ?headers:[(string*string)], ?format:string,
 ?dumpfile:string,
 ~process:(([(string*string)])-&gt;string),
 ?samplerate:int, ?header:bool,
 ?restart_on_crash:bool, ?restart_on_new_track:bool,
 ?restart_encoder_delay:int, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?start:bool, ?bitrate:int, ?quality:float,
 ?channels:int, ?icy_metadata:bool, source)-&gt;source</pre>
<p>
Output the source's stream to an Icecast2 compatible server using an external encoder.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>mount</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [name]&quot;</code>)</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>protocol</code> (<code>string</code> &ndash; defaults to <code>&quot;http&quot;</code>): Protocol of the streaming server: 'http' for Icecast, 'icy' for shoutcast.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>headers</code> (<code>[(string*string)]</code> &ndash; defaults to <code>[  ]</code>): Additional headers.</li>
<li>
<code>format</code> (<code>string</code> &ndash; defaults to <code>&quot;mp3&quot;</code>): Content-type (mime) for the format. “mp3” is a short-hand for mpeg audio, “ogg” for ogg data.</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>process</code> (<code>([(string*string)])-&gt;string</code>): External encoding process. Takes initial metadata and return the command to start.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>): Output sample rate.</li>
<li>
<code>header</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Write wav header at beginning of encoded input.</li>
<li>
<code>restart_on_crash</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart external process when it crashed. If false, liquidsoap exits.</li>
<li>
<code>restart_on_new_track</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart encoder on new track.</li>
<li>
<code>restart_encoder_delay</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Restart the encoder after this delay, in seconds.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Bitrate information for icecast. Not used if negative.</li>
<li>
<code>quality</code> (<code>float</code> &ndash; defaults to <code>-1.</code>): Quality information for icecast. Not used if negative.</li>
<li>
<code>channels</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Channels information for icecast. Not used if negative.</li>
<li>
<code>icy_metadata</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Send new metadata using the ICY protocol.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.icecast.flac</h5>
<pre class="syntax ">(?id:string, ?start:bool, ?restart:bool,
 ?restart_delay:int, ?host:string, ?port:int,
 ?user:string, ?password:string, ?genre:string,
 ?url:string, ?description:string, ?public:bool,
 ?dumpfile:string, ?mount:string, ?name:string,
 ?protocol:string, ?flac:string, ?quality:int,
 ?restart_on_crash:bool, ?restart_on_new_track:bool,
 ?restart_encoder_delay:int, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit), source)
 -&gt;source</pre>
<p>
Output to icecast using the flac command line encoder.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;output.icecast.flac&quot;</code>): Output's ID</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Start output threads on operator initialization.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net/&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>mount</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [name]&quot;</code>)</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>protocol</code> (<code>string</code> &ndash; defaults to <code>&quot;http&quot;</code>): Protocol of the streaming server: 'http' for Icecast, 'icy' for Shoutcast.</li>
<li>
<code>flac</code> (<code>string</code> &ndash; defaults to <code>&quot;flac&quot;</code>): The flac binary</li>
<li>
<code>quality</code> (<code>int</code> &ndash; defaults to <code>6</code>): Encoder quality (0..8)</li>
<li>
<code>restart_on_crash</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart external process on crash. If false, liquidsoap will stop.</li>
<li>
<code>restart_on_new_track</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Restart encoder upon new track. If false, the resulting stream will have a single track.</li>
<li>
<code>restart_encoder_delay</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Restart the encoder after this delay, in seconds.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>): The source to output</li>
</ul>
<h5>output.icecast.lame</h5>
<pre class="syntax ">(?id:string, ?start:bool, ?restart:bool,
 ?restart_delay:int, ?host:string, ?port:int,
 ?user:string, ?password:string, ?genre:string,
 ?url:string, ?description:string, ?public:bool,
 ?dumpfile:string, ?mount:string, ?name:string,
 ?protocol:string, ?lame:string, ?bitrate:int,
 ?swap:bool, ?fallible:bool, ?on_start:(()-&gt;unit),
 ?on_stop:(()-&gt;unit), ?restart_on_crash:bool,
 ?restart_on_new_track:bool,
 ?restart_encoder_delay:int,
 ?headers:[(string*string)], source)-&gt;source</pre>
<p>
Output to icecast using the lame command line encoder.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;output.icecast.lame&quot;</code>): Output's ID</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Start output threads on operator initialization.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net/&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>mount</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [name]&quot;</code>)</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>protocol</code> (<code>string</code> &ndash; defaults to <code>&quot;http&quot;</code>): Protocol of the streaming server: 'http' for Icecast, 'icy' for Shoutcast.</li>
<li>
<code>lame</code> (<code>string</code> &ndash; defaults to <code>&quot;lame&quot;</code>): The lame binary</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>128</code>): Encoder bitrate</li>
<li>
<code>swap</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Swap audio samples. Depends on local machine's endianess and lame's version. Test this parameter if you experience garbaged mp3 audio data. On intel 32 and 64 architectures, the parameter should be “true” for lame version &gt;= 3.98.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>restart_on_crash</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart external process on crash. If false, liquidsoap will stop.</li>
<li>
<code>restart_on_new_track</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart encoder upon new track.</li>
<li>
<code>restart_encoder_delay</code> (<code>int</code> &ndash; defaults to <code>3600</code>): Restart the encoder after this delay, in seconds.</li>
<li>
<code>headers</code> (<code>[(string*string)]</code> &ndash; defaults to <code>[  ]</code>)</li>
<li>
<code>(unlabeled)</code> (<code>source</code>): The source to output</li>
</ul>
<h5>output.icecast.mp3</h5>
<pre class="syntax ">(?id:string, ?restart:bool, ?restart_delay:int,
 ?mount:string, ?name:string, ?protocol:string,
 ?host:string, ?port:int, ?user:string,
 ?password:string, ?genre:string, ?url:string,
 ?description:string, ?public:bool,
 ?headers:[(string*string)], ?format:string,
 ?dumpfile:string, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?start:bool, ?samplerate:int, ?bitrate:int,
 ?quality:int, ?stereo:bool, source)-&gt;source</pre>
<p>
Output the source's stream to an icecast2-compatible server in MP3 format.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>mount</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [name]&quot;</code>)</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>protocol</code> (<code>string</code> &ndash; defaults to <code>&quot;http&quot;</code>): Protocol of the streaming server: 'http' for Icecast, 'icy' for shoutcast.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>headers</code> (<code>[(string*string)]</code> &ndash; defaults to <code>[  ]</code>): Additional headers.</li>
<li>
<code>format</code> (<code>string</code> &ndash; defaults to <code>&quot;mp3&quot;</code>): Content-type (mime) for the format. “mp3” is a short-hand for mpeg audio, “ogg” for ogg data.</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>)</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>128</code>)</li>
<li>
<code>quality</code> (<code>int</code> &ndash; defaults to <code>5</code>)</li>
<li>
<code>stereo</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.icecast.speex</h5>
<pre class="syntax ">(?id:string, ?samplerate:int, ?bitrate:int,
 ?quality:int, ?mode:string, ?stereo:bool,
 ?vbr:bool, ?frames_per_packet:int, ?complexity:int,
 ?abr:int, ?skeleton:bool, ?restart:bool,
 ?restart_delay:int, ?mount:string, ?name:string,
 ?protocol:string, ?host:string, ?port:int,
 ?user:string, ?password:string, ?genre:string,
 ?url:string, ?description:string, ?public:bool,
 ?headers:[(string*string)], ?format:string,
 ?dumpfile:string, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?start:bool, source)-&gt;source</pre>
<p>
Output the source stream as an Ogg Speex stream to an Icecast-compatible server.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Output sample rate. Use liquidsoap's default if &lt;= 0.</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Target bitrate (in kbps). Not used if &lt;= 0.</li>
<li>
<code>quality</code> (<code>int</code> &ndash; defaults to <code>7</code>): Target quality (0 to 10). Not used if &lt;= 0.</li>
<li>
<code>mode</code> (<code>string</code> &ndash; defaults to <code>&quot;narrowband&quot;</code>): Encoding mode, one of “narrowband”, “wideband” or “ultra-wideband”.</li>
<li>
<code>stereo</code> (<code>bool</code> &ndash; defaults to <code>false</code>)</li>
<li>
<code>vbr</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Encode in vbr mode.</li>
<li>
<code>frames_per_packet</code> (<code>int</code> &ndash; defaults to <code>1</code>): Number of frame per Ogg packet (1 to 10).</li>
<li>
<code>complexity</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Encoding complexity (0-10). Not used if &lt;= 0.</li>
<li>
<code>abr</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Set average bitrate. Not used if &lt;= 0.</li>
<li>
<code>skeleton</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Add an ogg skeleton to the stream. Recommended for theora only.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>mount</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [name].ogg&quot;</code>)</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>protocol</code> (<code>string</code> &ndash; defaults to <code>&quot;http&quot;</code>): Protocol of the streaming server: 'http' for Icecast, 'icy' for shoutcast.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>headers</code> (<code>[(string*string)]</code> &ndash; defaults to <code>[  ]</code>): Additional headers.</li>
<li>
<code>format</code> (<code>string</code> &ndash; defaults to <code>&quot;ogg&quot;</code>): Content-type (mime) for the format. “mp3” is a short-hand for mpeg audio, “ogg” for ogg data.</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.icecast.theora</h5>
<pre class="syntax ">(?id:string, ?quality:int, ?vorbis_quality:float,
 ?skeleton:bool, ?restart:bool, ?restart_delay:int,
 ?mount:string, ?name:string, ?protocol:string,
 ?host:string, ?port:int, ?user:string,
 ?password:string, ?genre:string, ?url:string,
 ?description:string, ?public:bool,
 ?headers:[(string*string)], ?format:string,
 ?dumpfile:string, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?start:bool, source)-&gt;source</pre>
<p>
Output the source stream as an Ogg Theora stream to an Icecast-compatible.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>quality</code> (<code>int</code> &ndash; defaults to <code>100</code>): Quality setting for theora encoding.</li>
<li>
<code>vorbis_quality</code> (<code>float</code> &ndash; defaults to <code>2.</code>): Quality setting for vorbis encoding. Don't encode audio if value is negative or null.</li>
<li>
<code>skeleton</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Add an ogg skeleton to the stream. Recommended for theora only.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>mount</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [name].ogg&quot;</code>)</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>protocol</code> (<code>string</code> &ndash; defaults to <code>&quot;http&quot;</code>): Protocol of the streaming server: 'http' for Icecast, 'icy' for shoutcast.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>headers</code> (<code>[(string*string)]</code> &ndash; defaults to <code>[  ]</code>): Additional headers.</li>
<li>
<code>format</code> (<code>string</code> &ndash; defaults to <code>&quot;ogg&quot;</code>): Content-type (mime) for the format. “mp3” is a short-hand for mpeg audio, “ogg” for ogg data.</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.icecast.vorbis</h5>
<pre class="syntax ">(?id:string, ?samplerate:int, ?stereo:bool,
 ?skeleton:bool, ?restart:bool, ?restart_delay:int,
 ?mount:string, ?name:string, ?protocol:string,
 ?host:string, ?port:int, ?user:string,
 ?password:string, ?genre:string, ?url:string,
 ?description:string, ?public:bool,
 ?headers:[(string*string)], ?format:string,
 ?dumpfile:string, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?start:bool, source, ?quality:float)-&gt;source</pre>
<p>
Output the source stream as an Ogg Vorbis stream to an Icecast-compatible server in Variable BitRate mode.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>)</li>
<li>
<code>stereo</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>skeleton</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Add an ogg skeleton to the stream. Recommended for theora only.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>mount</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [name].ogg&quot;</code>)</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>protocol</code> (<code>string</code> &ndash; defaults to <code>&quot;http&quot;</code>): Protocol of the streaming server: 'http' for Icecast, 'icy' for shoutcast.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>headers</code> (<code>[(string*string)]</code> &ndash; defaults to <code>[  ]</code>): Additional headers.</li>
<li>
<code>format</code> (<code>string</code> &ndash; defaults to <code>&quot;ogg&quot;</code>): Content-type (mime) for the format. “mp3” is a short-hand for mpeg audio, “ogg” for ogg data.</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
<li>
<code>quality</code> (<code>float</code> &ndash; defaults to <code>2.</code>): Desired quality level, currently from -1. to 10. (low to high).</li>
</ul>
<h5>output.icecast.vorbis.abr</h5>
<pre class="syntax ">(?id:string, ?samplerate:int, ?stereo:bool,
 ?skeleton:bool, ?restart:bool, ?restart_delay:int,
 ?mount:string, ?name:string, ?protocol:string,
 ?host:string, ?port:int, ?user:string,
 ?password:string, ?genre:string, ?url:string,
 ?description:string, ?public:bool,
 ?headers:[(string*string)], ?format:string,
 ?dumpfile:string, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?start:bool, source, ?bitrate:int,
 ?min_bitrate:int, ?max_bitrate:int)-&gt;source</pre>
<p>
Output the source stream as an Ogg Vorbis stream to an Icecast-compatible server in Average BitRate mode.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>)</li>
<li>
<code>stereo</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>skeleton</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Add an ogg skeleton to the stream. Recommended for theora only.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>mount</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [name].ogg&quot;</code>)</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>protocol</code> (<code>string</code> &ndash; defaults to <code>&quot;http&quot;</code>): Protocol of the streaming server: 'http' for Icecast, 'icy' for shoutcast.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>headers</code> (<code>[(string*string)]</code> &ndash; defaults to <code>[  ]</code>): Additional headers.</li>
<li>
<code>format</code> (<code>string</code> &ndash; defaults to <code>&quot;ogg&quot;</code>): Content-type (mime) for the format. “mp3” is a short-hand for mpeg audio, “ogg” for ogg data.</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>128</code>): Target bitrate (in kbps).</li>
<li>
<code>min_bitrate</code> (<code>int</code> &ndash; defaults to <code>118</code>): Minimum bitrate (in kbps).</li>
<li>
<code>max_bitrate</code> (<code>int</code> &ndash; defaults to <code>138</code>): Maximum bitrate (in kbps).</li>
</ul>
<h5>output.icecast.vorbis.cbr</h5>
<pre class="syntax ">(?id:string, ?samplerate:int, ?stereo:bool,
 ?skeleton:bool, ?restart:bool, ?restart_delay:int,
 ?mount:string, ?name:string, ?protocol:string,
 ?host:string, ?port:int, ?user:string,
 ?password:string, ?genre:string, ?url:string,
 ?description:string, ?public:bool,
 ?headers:[(string*string)], ?format:string,
 ?dumpfile:string, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?start:bool, source, ?bitrate:int)-&gt;source</pre>
<p>
Output the source stream as an Ogg Vorbis stream to an Icecast-compatible server in Constant BitRate mode.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>)</li>
<li>
<code>stereo</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>skeleton</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Add an ogg skeleton to the stream. Recommended for theora only.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>mount</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [name].ogg&quot;</code>)</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>protocol</code> (<code>string</code> &ndash; defaults to <code>&quot;http&quot;</code>): Protocol of the streaming server: 'http' for Icecast, 'icy' for shoutcast.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>headers</code> (<code>[(string*string)]</code> &ndash; defaults to <code>[  ]</code>): Additional headers.</li>
<li>
<code>format</code> (<code>string</code> &ndash; defaults to <code>&quot;ogg&quot;</code>): Content-type (mime) for the format. “mp3” is a short-hand for mpeg audio, “ogg” for ogg data.</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>128</code>): Bitrate (in kbps).</li>
</ul>
<h5>output.jack</h5>
<pre class="syntax ">(?id:string, ?fallible:bool, ?on_start:(()-&gt;unit),
 ?on_stop:(()-&gt;unit), ?start:bool, ?buffer_size:int,
 ?server:string, source)-&gt;source</pre>
<p>
Output stream to jack.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>buffer_size</code> (<code>int</code> &ndash; defaults to <code>2</code>): Set buffer size, in frames.</li>
<li>
<code>server</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Jack server to connect to.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.jack.legacy</h5>
<pre class="syntax ">(?id:string, ?ports:[string], ?synchronize:bool,
 source)-&gt;source</pre>
<p>
WARNING: This is DEPRECATED!
</p>
<p>
Deprecated jack output.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>ports</code> (<code>[string]</code> &ndash; defaults to <code>[ &quot;output_0&quot;, &quot;output_1&quot; ]</code>): Port names.</li>
<li>
<code>synchronize</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Synchronize on jack output.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.marshal</h5>
<pre class="syntax ">(?id:string, ?reopen:bool, string, source)-&gt;source</pre>
<p>
WARNING: This is only EXPERIMENTAL!
</p>
<p>
Output the source's stream to a pipe using marshaling.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>reopen</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Try to reopen the pipe after a failure.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>): Pipe to send the stream to.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.oss</h5>
<pre class="syntax ">(?id:string, ?device:string, source)-&gt;source</pre>
<p>
Output the source's stream to an OSS output device.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>device</code> (<code>string</code> &ndash; defaults to <code>&quot;/dev/dsp&quot;</code>): OSS device to use.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.pipe.external</h5>
<pre class="syntax ">(?id:string, ?start:bool,
 ~process:(([(string*string)])-&gt;string),
 ?samplerate:int, ?header:bool,
 ?restart_on_crash:bool, ?restart_on_new_track:bool,
 ?restart_encoder_delay:int, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?start:bool, source)-&gt;source</pre>
<p>
Output the source's stream to an external process.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Start output threads on operator initialization.</li>
<li>
<code>process</code> (<code>([(string*string)])-&gt;string</code>): External encoding process. Takes initial metadata and return the command to start.</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>): Output sample rate.</li>
<li>
<code>header</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Write wav header at beginning of encoded input.</li>
<li>
<code>restart_on_crash</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart external process when it crashed. If false, liquidsoap exits.</li>
<li>
<code>restart_on_new_track</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart encoder on new track.</li>
<li>
<code>restart_encoder_delay</code> (<code>int</code> &ndash; defaults to <code>-1</code>): Restart the encoder after this delay, in seconds.</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Automatically start outputting whenever possible. If true, an infallible (normal) output will start outputting as soon as it is created, and a fallible output will (re)start as soon as its source becomes available for streaming.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.portaudio</h5>
<pre class="syntax ">(?id:string, ?buflen:int, source)-&gt;source</pre>
<p>
Output the source's stream to a portaudio output device.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>buflen</code> (<code>int</code> &ndash; defaults to <code>256</code>): Length of a buffer in samples.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.prefered</h5>
<pre class="syntax ">(?id:string, source)-&gt;source</pre>
<p>
Output to local audio card using the first available driver in this list:
ao, pulseaudio, alsa, oss, dummy
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.pulseaudio</h5>
<pre class="syntax ">(?id:string, ?client:string, ?device:string, source)
 -&gt;source</pre>
<p>
Output the source's stream to a portaudio output device.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>client</code> (<code>string</code> &ndash; defaults to <code>&quot;liquidsoap&quot;</code>)</li>
<li>
<code>device</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Device to use. Uses default if set to “”.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>output.shoutcast.aacplus</h5>
<pre class="syntax ">(?id:string, ?start:bool, ?restart:bool,
 ?restart_delay:int, ?host:string, ?port:int,
 ?user:string, ?password:string, ?genre:string,
 ?url:string, ?description:string, ?public:bool,
 ?dumpfile:string, ?name:string, ?aim:string,
 ?icq:string, ?irc:string, ?icy_reset:bool,
 ?bitrate:int, ?samplerate:int, ?fallible:bool,
 ?on_start:(()-&gt;unit), ?on_stop:(()-&gt;unit),
 ?format:string, source)-&gt;source</pre>
<p>
Output to shoutcast using the AAC+ format.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;output.shoutcast.aacplus&quot;</code>): Output's ID</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Start output threads on operator initialization.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net/&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>aim</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>icq</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>irc</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>icy_reset</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Reset shoutcast source buffer upon connecting (necessary for NSV).</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>64</code>): Encoder bitrate</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>)</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>format</code> (<code>string</code> &ndash; defaults to <code>&quot;audio/aacp&quot;</code>)</li>
<li>
<code>(unlabeled)</code> (<code>source</code>): The source to output</li>
</ul>
<h5>output.shoutcast.aacplusenc</h5>
<pre class="syntax ">(?id:string, ?start:bool, ?restart:bool,
 ?restart_delay:int, ?host:string, ?port:int,
 ?user:string, ?password:string, ?genre:string,
 ?url:string, ?description:string, ?public:bool,
 ?fallible:bool, ?on_start:(()-&gt;unit),
 ?on_stop:(()-&gt;unit), ?dumpfile:string,
 ?name:string, ?icy_reset:bool, ?aim:string,
 ?icq:string, ?irc:string, ?aacplusenc:string,
 ?restart_on_crash:bool, ?restart_on_new_track:bool,
 ?restart_encoder_delay:int, ?bitrate:int, source)
 -&gt;source</pre>
<p>
Output to shoutcast using the aacplusenc encoder.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;output.shoutcast.aacplusenc&quot;</code>): Output's ID</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Start output threads on operator initialization.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net/&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>icy_reset</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Reset shoutcast source buffer upon connecting (necessary for NSV).</li>
<li>
<code>aim</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>icq</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>irc</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>aacplusenc</code> (<code>string</code> &ndash; defaults to <code>&quot;aacplusenc&quot;</code>): The aacplusenc binary</li>
<li>
<code>restart_on_crash</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart external process on crash. If false, liquidsoap will stop.</li>
<li>
<code>restart_on_new_track</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart encoder upon new track.</li>
<li>
<code>restart_encoder_delay</code> (<code>int</code> &ndash; defaults to <code>3600</code>): Restart the encoder after this delay, in seconds.</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>64</code>): Encoder bitrate</li>
<li>
<code>(unlabeled)</code> (<code>source</code>): The source to output</li>
</ul>
<h5>output.shoutcast.lame</h5>
<pre class="syntax ">(?id:string, ?start:bool, ?restart:bool,
 ?restart_delay:int, ?host:string, ?port:int,
 ?user:string, ?password:string, ?genre:string,
 ?url:string, ?description:string, ?public:bool,
 ?dumpfile:string, ?name:string, ?icy_reset:bool,
 ?lame:string, ?aim:string, ?icq:string,
 ?irc:string, ?fallible:bool, ?on_start:(()-&gt;unit),
 ?on_stop:(()-&gt;unit), ?restart_on_crash:bool,
 ?restart_on_new_track:bool,
 ?restart_encoder_delay:int, ?bitrate:int, source)
 -&gt;source</pre>
<p>
Output to shoutcast using the lame encoder.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;output.shoutcast.mp3&quot;</code>): Output's ID</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Start output threads on operator initialization.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net/&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>icy_reset</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Reset shoutcast source buffer upon connecting (necessary for NSV).</li>
<li>
<code>lame</code> (<code>string</code> &ndash; defaults to <code>&quot;lame&quot;</code>): The lame binary</li>
<li>
<code>aim</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>icq</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>irc</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>restart_on_crash</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart external process on crash. If false, liquidsoap will stop.</li>
<li>
<code>restart_on_new_track</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart encoder upon new track.</li>
<li>
<code>restart_encoder_delay</code> (<code>int</code> &ndash; defaults to <code>3600</code>): Restart the encoder after this delay, in seconds.</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>128</code>): Encoder bitrate</li>
<li>
<code>(unlabeled)</code> (<code>source</code>): The source to output</li>
</ul>
<h5>output.shoutcast.mp3</h5>
<pre class="syntax ">(?id:string, ?start:bool, ?restart:bool,
 ?restart_delay:int, ?host:string, ?port:int,
 ?user:string, ?password:string, ?genre:string,
 ?url:string, ?description:string, ?public:bool,
 ?dumpfile:string, ?name:string, ?aim:string,
 ?icq:string, ?irc:string, ?icy_reset:bool,
 ?bitrate:int, ?samplerate:int, ?stereo:bool,
 ?fallible:bool, ?on_start:(()-&gt;unit),
 ?on_stop:(()-&gt;unit), source)-&gt;source</pre>
<p>
Output to shoutcast using the MP3 format.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;output.shoutcast.mp3&quot;</code>): Output's ID</li>
<li>
<code>start</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Start output threads on operator initialization.</li>
<li>
<code>restart</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Restart output after a failure. By default, liquidsoap will stop if the output failed.</li>
<li>
<code>restart_delay</code> (<code>int</code> &ndash; defaults to <code>3</code>): Delay, in seconds, before attempting new connection, if restart is enabled.</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;localhost&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>8000</code>)</li>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;source&quot;</code>): User for shout source connection. Useful only in special cases, like with per-mountpoint users.</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;hackme&quot;</code>)</li>
<li>
<code>genre</code> (<code>string</code> &ndash; defaults to <code>&quot;Misc&quot;</code>)</li>
<li>
<code>url</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;http://savonet.sf.net&quot;:http://savonet.sf.net/&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;OCaml Radio!&quot;</code>)</li>
<li>
<code>public</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>dumpfile</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Dump stream to file, for debugging purpose. Disabled if empty.</li>
<li>
<code>name</code> (<code>string</code> &ndash; defaults to <code>&quot;Use [mount]&quot;</code>)</li>
<li>
<code>aim</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>icq</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>irc</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>icy_reset</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Reset shoutcast source buffer upon connecting (necessary for NSV).</li>
<li>
<code>bitrate</code> (<code>int</code> &ndash; defaults to <code>128</code>): Encoder bitrate</li>
<li>
<code>samplerate</code> (<code>int</code> &ndash; defaults to <code>44100</code>)</li>
<li>
<code>stereo</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>fallible</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow the child source to fail, in which case the output will be (temporarily) stopped.</li>
<li>
<code>on_start</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting starts.</li>
<li>
<code>on_stop</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Callback executed when outputting stops.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>): The source to output</li>
</ul>
<h3><a name="SourceSoundProcessing">Source / Sound Processing</a></h3>
<h5>accelerate</h5>
<pre class="syntax ">(?id:string, float, ?before:float, ?after:float,
 source)-&gt;source</pre>
<p>
WARNING: This is only EXPERIMENTAL!
</p>
<p>
Accelerates a stream, possibly only the middle of the tracks. Useful for testing transitions.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>float</code>)</li>
<li>
<code>before</code> (<code>float</code> &ndash; defaults to <code>10.</code>): Do not accelerate during that period of time at the beginning of a track.</li>
<li>
<code>after</code> (<code>float</code> &ndash; defaults to <code>10.</code>): Do not accelerate during that period of time before the end of a track.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>add</h5>
<pre class="syntax ">(?id:string, ?normalize:bool, ?weights:[int],
 [source])-&gt;source</pre>
<p>
Mix sources, with optional normalization. Only relay metadata from the first source that is effectively summed.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>normalize</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>weights</code> (<code>[int]</code> &ndash; defaults to <code>[  ]</code>): Relative weight of the sources in the sum. The empty list stands for the homogeneous distribution.</li>
<li>
<code>(unlabeled)</code> (<code>[source]</code>)</li>
</ul>
<h5>amplify</h5>
<pre class="syntax ">(?id:string, 'a, ?override:string,
 source)-&gt;source where 'a is either float or ()
 -&gt;float</pre>
<p>
Multiply the amplitude of the signal.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>anything that is either float or ()-&gt;float</code>): Multiplicative factor.</li>
<li>
<code>override</code> (<code>string</code> &ndash; defaults to <code>&quot;liq_amplify&quot;</code>): Specify the name of a metadata field that, when present and well-formed, overrides the amplification factor for the current track. Well-formed values are floats in decimal notation (e.g. '0.7') which are taken as normal/linear multiplicative factors; values can be passed in decibels with the suffix 'dB' (e.g. '-8.2 dB', but the spaces do not matter).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>bpm</h5>
<pre class="syntax ">(?id:string, ?every:int, source)-&gt;source</pre>
<p>
WARNING: This is only EXPERIMENTAL!
</p>
<p>
Detect the BPM.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>every</code> (<code>int</code> &ndash; defaults to <code>500</code>)</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>clip</h5>
<pre class="syntax ">(?id:string, ?min:float, ?max:float, source)
 -&gt;source</pre>
<p>
Clip sound.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>min</code> (<code>float</code> &ndash; defaults to <code>-0.999</code>): Minimal acceptable value.</li>
<li>
<code>max</code> (<code>float</code> &ndash; defaults to <code>0.999</code>): Maximal acceptable value.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>comb</h5>
<pre class="syntax ">(?id:string, ?delay:float, ?feedback:'a,
 source)-&gt;source where 'a is either float or ()
 -&gt;float</pre>
<p>
Comb filter.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>delay</code> (<code>float</code> &ndash; defaults to <code>0.001</code>): Delay in seconds.</li>
<li>
<code>feedback</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>-6.</code>): Feedback coefficient in dB.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>compand</h5>
<pre class="syntax ">(?id:string, ?mu:float, source)-&gt;source</pre>
<p>
Compand the signal
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>mu</code> (<code>float</code> &ndash; defaults to <code>1.</code>)</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>compress</h5>
<pre class="syntax ">(?id:string, ?ratio:float, ?attack:'a, ?release:'b,
 ?threshold:'c, ?knee:'d, ?rms_window:float,
 ?gain:'e, ?debug:bool, source)-&gt;source where 'a,
 'b, 'c, 'd, 'e is either float or ()-&gt;float</pre>
<p>
Compress the signal.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>ratio</code> (<code>float</code> &ndash; defaults to <code>2.</code>): Gain reduction ratio (n:1).</li>
<li>
<code>attack</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>100.</code>): Attack time (ms).</li>
<li>
<code>release</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>400.</code>): Release time (ms).</li>
<li>
<code>threshold</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>-10.</code>): Threshold level (dB).</li>
<li>
<code>knee</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>1.</code>): Knee radius (dB).</li>
<li>
<code>rms_window</code> (<code>float</code> &ndash; defaults to <code>0.1</code>): Window for computing RMS (in sec).</li>
<li>
<code>gain</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>0.</code>): Additional gain (dB).</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>)</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>compress.exponential</h5>
<pre class="syntax ">(?id:string, ?mu:float, source)-&gt;source</pre>
<p>
Exponential compressor.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>mu</code> (<code>float</code> &ndash; defaults to <code>2.</code>): Exponential compression factor, typically greater than 1.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>cross</h5>
<pre class="syntax ">(?id:string, ?duration:float, ?override:string,
 ?inhibit:float, ?minimum:float, ?conservative:bool,
 ((source, source)-&gt;source), source)-&gt;source</pre>
<p>
Generic cross operator, allowing the composition of the N last seconds of a track with the beginning of the next track.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>5.</code>): Duration in seconds of the crossed end of track. This value can be changed on a per-file basis using a special metadata field.</li>
<li>
<code>override</code> (<code>string</code> &ndash; defaults to <code>&quot;liq_start_next&quot;</code>): Metadata field which, if present and containing a float, overrides the 'duration' parameter for current track.</li>
<li>
<code>inhibit</code> (<code>float</code> &ndash; defaults to <code>-1.</code>): Minimum delay between two transitions. It is useful in order to avoid that a transition is triggered on top of another when an end-of-track occurs in the first one. Negative values mean <code>duration+1</code>. Warning: zero inhibition can cause infinite loops.</li>
<li>
<code>minimum</code> (<code>float</code> &ndash; defaults to <code>-1.</code>): Minimum duration (in sec.) for a cross: If the track ends without any warning (e.g. in case of skip) there may not be enough data for a decent composition. Set to 0. to avoid having transitions after skips, or more to avoid transitions on short tracks. With the negative default, transitions always occur.</li>
<li>
<code>conservative</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Do not trust remaining time estimations, always buffering data in advance. This avoids being tricked by skips, either manual or caused by skip_blank().</li>
<li>
<code>(unlabeled)</code> (<code>(source, source)-&gt;source</code>): Composition of an end of track and the next track.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>echo</h5>
<pre class="syntax ">(?id:string, ?delay:float, ?feedback:'a,
 source)-&gt;source where 'a is either float or ()
 -&gt;float</pre>
<p>
Add echo.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>delay</code> (<code>float</code> &ndash; defaults to <code>0.5</code>): Delay in seconds.</li>
<li>
<code>feedback</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>-6.</code>): Feedback coefficient in dB (negative).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>fade.final</h5>
<pre class="syntax ">(?id:string, ?duration:float, ?type:string, source)
 -&gt;source</pre>
<p>
Fade a stream to silence.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>3.</code>): Duration of the fading. This value can be set on a per-file basis using the metadata field passed as override.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>fade.in</h5>
<pre class="syntax ">(?id:string, ?override:string, ?duration:float,
 ?type:string, source)-&gt;source</pre>
<p>
Fade the beginning of tracks. Metadata 'liq_fade_in' can be used to set the duration for a specific track (float in seconds).
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>override</code> (<code>string</code> &ndash; defaults to <code>&quot;liq_fade_in&quot;</code>): Metadata field which, if present and containing a float, overrides the 'duration' parameter for current track.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>3.</code>): Duration of the fading. This value can be set on a per-file basis using the metadata field passed as override.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>fade.initial</h5>
<pre class="syntax ">(?id:string, ?duration:float, ?type:string, source)
 -&gt;source</pre>
<p>
Fade the beginning of a stream.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>3.</code>): Duration of the fading. This value can be set on a per-file basis using the metadata field passed as override.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>fade.out</h5>
<pre class="syntax ">(?id:string, ?override:string, ?duration:float,
 ?type:string, source)-&gt;source</pre>
<p>
Fade the end of tracks. Metadata 'liq_fade_out' can be used to set the duration for a specific track (float in seconds).
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>override</code> (<code>string</code> &ndash; defaults to <code>&quot;liq_fade_out&quot;</code>): Metadata field which, if present and containing a float, overrides the 'duration' parameter for current track.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>3.</code>): Duration of the fading. This value can be set on a per-file basis using the metadata field passed as override.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter</h5>
<pre class="syntax ">(?id:string, ~freq:'a, ?q:'b, ~mode:string,
 ?wetness:'c, source)-&gt;source where 'a, 'b,
 'c is either float or ()-&gt;float</pre>
<p>
Perform several kinds of filtering on the signal
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>freq</code> (<code>anything that is either float or ()-&gt;float</code>)</li>
<li>
<code>q</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>1.</code>)</li>
<li>
<code>mode</code> (<code>string</code>): Available modes are 'low', 'high', 'band' and 'notch'.</li>
<li>
<code>wetness</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>1.</code>): How much of the original signal should be added (1. means only filtered and 0. means only original signal).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.fir</h5>
<pre class="syntax ">(?id:string, ~frequency:float, ~beta:float,
 ?coeffs:int, ?debug:bool, source)-&gt;source</pre>
<p>
Low-pass FIR filter.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency</code> (<code>float</code>): Corner frequency in Hz (frequency at which the response is 0.5, that is -6 dB).</li>
<li>
<code>beta</code> (<code>float</code>): Beta should range between 0 and 1.</li>
<li>
<code>coeffs</code> (<code>int</code> &ndash; defaults to <code>255</code>): Number of coefficients</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.butterworth.bandpass</h5>
<pre class="syntax ">(?id:string, ~frequency1:float, ~frequency2:float,
 ?order:int, ?debug:bool, source)-&gt;source</pre>
<p>
IIR filter
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency1</code> (<code>float</code>): First corner frequency</li>
<li>
<code>frequency2</code> (<code>float</code>): Second corner frequency</li>
<li>
<code>order</code> (<code>int</code> &ndash; defaults to <code>4</code>): Filter order</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.butterworth.bandstop</h5>
<pre class="syntax ">(?id:string, ~frequency1:float, ~frequency2:float,
 ?order:int, ?debug:bool, source)-&gt;source</pre>
<p>
IIR filter
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency1</code> (<code>float</code>): First corner frequency</li>
<li>
<code>frequency2</code> (<code>float</code>): Second corner frequency</li>
<li>
<code>order</code> (<code>int</code> &ndash; defaults to <code>4</code>): Filter order</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.butterworth.high</h5>
<pre class="syntax ">(?id:string, ~frequency:float, ?order:int,
 ?debug:bool, source)-&gt;source</pre>
<p>
IIR filter
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency</code> (<code>float</code>): Corner frequency</li>
<li>
<code>order</code> (<code>int</code> &ndash; defaults to <code>4</code>): Filter order</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.butterworth.low</h5>
<pre class="syntax ">(?id:string, ~frequency:float, ?order:int,
 ?debug:bool, source)-&gt;source</pre>
<p>
IIR filter
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency</code> (<code>float</code>): Corner frequency</li>
<li>
<code>order</code> (<code>int</code> &ndash; defaults to <code>4</code>): Filter order</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.eq.allpass</h5>
<pre class="syntax ">(?id:string, ~frequency:float, ?bandwidth:float,
 ?debug:bool, source)-&gt;source</pre>
<p>
All pass biquad filter.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency</code> (<code>float</code>): Center frequency</li>
<li>
<code>bandwidth</code> (<code>float</code> &ndash; defaults to <code>0.333333333333</code>): Bandwidth (in octaves)</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.eq.bandpass</h5>
<pre class="syntax ">(?id:string, ~frequency:float, ?q:float,
 ?debug:bool, source)-&gt;source</pre>
<p>
Band pass biquad filter.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency</code> (<code>float</code>): Center frequency</li>
<li>
<code>q</code> (<code>float</code> &ndash; defaults to <code>1.</code>): Q</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.eq.high</h5>
<pre class="syntax ">(?id:string, ~frequency:float, ?q:float,
 ?debug:bool, source)-&gt;source</pre>
<p>
High pass biquad filter.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency</code> (<code>float</code>): Corner frequency</li>
<li>
<code>q</code> (<code>float</code> &ndash; defaults to <code>1.</code>): Q</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.eq.highshelf</h5>
<pre class="syntax ">(?id:string, ~frequency:float, ?slope:float,
 ?debug:bool, source)-&gt;source</pre>
<p>
High shelf biquad filter.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency</code> (<code>float</code>): Center frequency</li>
<li>
<code>slope</code> (<code>float</code> &ndash; defaults to <code>1.</code>): Shelf slope (in dB/octave)</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.eq.low</h5>
<pre class="syntax ">(?id:string, ~frequency:float, ?q:float,
 ?debug:bool, source)-&gt;source</pre>
<p>
Low pass biquad filter.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency</code> (<code>float</code>): Corner frequency</li>
<li>
<code>q</code> (<code>float</code> &ndash; defaults to <code>1.</code>): Q</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.eq.lowshelf</h5>
<pre class="syntax ">(?id:string, ~frequency:float, ?slope:float,
 ?debug:bool, source)-&gt;source</pre>
<p>
Low shelf biquad filter.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency</code> (<code>float</code>): Corner frequency</li>
<li>
<code>slope</code> (<code>float</code> &ndash; defaults to <code>1.</code>): Shelf slope (dB/octave)</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.eq.notch</h5>
<pre class="syntax ">(?id:string, ~frequency:float, ?q:float,
 ?debug:bool, source)-&gt;source</pre>
<p>
Band pass biquad filter.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency</code> (<code>float</code>): Center frequency</li>
<li>
<code>q</code> (<code>float</code> &ndash; defaults to <code>1.</code>): Q</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.eq.peak</h5>
<pre class="syntax ">(?id:string, ~frequency:float, ?q:float,
 ?gain:float, ?debug:bool, source)-&gt;source</pre>
<p>
Peak EQ biquad filter.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency</code> (<code>float</code>): Center frequency</li>
<li>
<code>q</code> (<code>float</code> &ndash; defaults to <code>1.</code>): Q</li>
<li>
<code>gain</code> (<code>float</code> &ndash; defaults to <code>1.</code>): Gain (in dB)</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.resonator.allpass</h5>
<pre class="syntax ">(?id:string, ~frequency:float, ?q:float,
 ?debug:bool, source)-&gt;source</pre>
<p>
IIR filter
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency</code> (<code>float</code>): Corner frequency</li>
<li>
<code>q</code> (<code>float</code> &ndash; defaults to <code>60.</code>): Quality factor</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.resonator.bandpass</h5>
<pre class="syntax ">(?id:string, ~frequency:float, ?q:float,
 ?debug:bool, source)-&gt;source</pre>
<p>
IIR filter
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency</code> (<code>float</code>): Corner frequency</li>
<li>
<code>q</code> (<code>float</code> &ndash; defaults to <code>60.</code>): Quality factor</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>filter.iir.resonator.bandstop</h5>
<pre class="syntax ">(?id:string, ~frequency:float, ?q:float,
 ?debug:bool, source)-&gt;source</pre>
<p>
IIR filter
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>frequency</code> (<code>float</code>): Corner frequency</li>
<li>
<code>q</code> (<code>float</code> &ndash; defaults to <code>60.</code>): Quality factor</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Debug output</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>flanger</h5>
<pre class="syntax ">(?id:string, ?delay:float, ?freq:'a, ?feedback:'b,
 ?phase:'c, source)-&gt;source where 'a, 'b,
 'c is either float or ()-&gt;float</pre>
<p>
Flanger effect.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>delay</code> (<code>float</code> &ndash; defaults to <code>0.001</code>): Delay in seconds.</li>
<li>
<code>freq</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>0.5</code>): Frequency in Hz.</li>
<li>
<code>feedback</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>0.</code>): Feedback coefficient in dB.</li>
<li>
<code>phase</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>1.</code>): Phasse difference between channels in radians.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>helium</h5>
<pre class="syntax ">(source)-&gt;source</pre>
<p>
Increases the pitch, making voices sound like on helium.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>source</code>): The input source.</li>
</ul>
<h5>insert_metadata</h5>
<pre class="syntax ">(?id:string, source)-&gt;source</pre>
<p>
Interactively insert metadata using the command <code>ID.insert key1="val1",key2="val2",...</code>.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>lag</h5>
<pre class="syntax ">(?id:string, float, source)-&gt;source</pre>
<p>
Add a constant delay to a stream, filling with blank when not available. This operator should be used just before the final output.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>float</code>): Delay in seconds.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>): Original source. Must be infaillible.</li>
</ul>
<h5>limit</h5>
<pre class="syntax ">(?id:string, ?ratio:float, ?attack:'a, ?release:'b,
 ?threshold:'c, ?knee:'d, ?rms_window:float,
 ?gain:'e, ?debug:bool, source)-&gt;source where 'a,
 'b, 'c, 'd, 'e is either float or ()-&gt;float</pre>
<p>
Limit the signal.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>ratio</code> (<code>float</code> &ndash; defaults to <code>20.</code>): Gain reduction ratio (n:1).</li>
<li>
<code>attack</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>100.</code>): Attack time (ms).</li>
<li>
<code>release</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>400.</code>): Release time (ms).</li>
<li>
<code>threshold</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>-10.</code>): Threshold level (dB).</li>
<li>
<code>knee</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>1.</code>): Knee radius (dB).</li>
<li>
<code>rms_window</code> (<code>float</code> &ndash; defaults to <code>0.1</code>): Window for computing RMS (in sec).</li>
<li>
<code>gain</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>0.</code>): Additional gain (dB).</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>)</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>mean</h5>
<pre class="syntax ">(?id:string, ?channels:[int], source)-&gt;source</pre>
<p>
Compute the mean of a list of audio channels and use it for all of them.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>channels</code> (<code>[int]</code> &ndash; defaults to <code>[ 0, 1 ]</code>): List of channels to compute the means.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>mic_filter</h5>
<pre class="syntax ">(source)-&gt;source</pre>
<p>
Remove low frequencies often produced by microphones.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>source</code>): The input source.</li>
</ul>
<h5>mix</h5>
<pre class="syntax ">(?id:string, [source])-&gt;source</pre>
<p>
Mixing table controllable via the telnet interface.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>[source]</code>)</li>
</ul>
<h5>normalize</h5>
<pre class="syntax ">(?id:string, ?target:'a, ?window:float, ?k_up:'b,
 ?k_down:'c, ?threshold:'d, ?gain_min:'e,
 ?gain_max:'f, ?debug:bool,
 source)-&gt;source where 'a, 'b, 'c, 'd, 'e,
 'f is either float or ()-&gt;float</pre>
<p>
Normalize the signal. Dynamic normalization of the signal is sometimes the only option, and can make a listening experience much nicer. However, its dynamic aspect implies some limitations which can go as far as creating saturation in some extreme cases. If possible, consider using some track-based normalization techniques such as those based on replay gain. See the documentation for more details.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>target</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>-13.</code>): Desired RMS (dB).</li>
<li>
<code>window</code> (<code>float</code> &ndash; defaults to <code>0.1</code>): Duration of the window used to compute the current RMS power (second).</li>
<li>
<code>k_up</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>0.005</code>): Coefficient when the power must go up (between 0 and 1, slowest to fastest).</li>
<li>
<code>k_down</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>0.1</code>): Coefficient when the power must go down (between 0 and 1, slowest to fastest).</li>
<li>
<code>threshold</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>-40.</code>): Minimal RMS for activaing gain control (dB).</li>
<li>
<code>gain_min</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>-6.</code>): Minimal gain value (dB).</li>
<li>
<code>gain_max</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>6.</code>): Maximal gain value (dB).</li>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Show coefficients.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>nrj</h5>
<pre class="syntax ">(source)-&gt;source</pre>
<p>
Compress and normalize, producing a more uniform and “full” sound.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>source</code>): The input source.</li>
</ul>
<h5>resample</h5>
<pre class="syntax ">(?id:string, ~ratio:'a,
 source)-&gt;source where 'a is either float or ()
 -&gt;float</pre>
<p>
Resample source's sound using a resampling factor
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>ratio</code> (<code>anything that is either float or ()-&gt;float</code>): Conversion ratio</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>sky</h5>
<pre class="syntax ">(source)-&gt;source</pre>
<p>
Multiband-compression.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>source</code>): The input source.</li>
</ul>
<h5>smart_cross</h5>
<pre class="syntax ">(?id:string, ?duration:float, ?inhibit:float,
 ?minimum:float, ?width:float, ?conservative:bool,
 ((float, float, [(string*string)],
 [(string*string)], source, source)-&gt;source),
 source)-&gt;source</pre>
<p>
Cross operator, allowing the composition of the N last seconds of a track with the beginning of the next track, using a transition function depending on the relative power of the signal before and after the end of track.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>5.</code>): Duration in seconds of the crossed end of track.</li>
<li>
<code>inhibit</code> (<code>float</code> &ndash; defaults to <code>-1.</code>): Minimum delay between two transitions. It is useful in order to avoid that a transition is triggered on top of another when an end-of-track occurs in the first one. Negative values mean <code>duration+1</code>. Warning: zero inhibition can cause infinite loops.</li>
<li>
<code>minimum</code> (<code>float</code> &ndash; defaults to <code>-1.</code>): Minimum duration (in sec.) for a cross: If the track ends without any warning (e.g. in case of skip) there may not be enough data for a decent composition. Set to 0. to avoid having transitions after skips, or more to avoid transitions on short tracks. With the negative default, transitions always occur.</li>
<li>
<code>width</code> (<code>float</code> &ndash; defaults to <code>1.</code>): Width of the power computation window.</li>
<li>
<code>conservative</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Do not trust remaining time estimations, always buffering data in advance. This avoids being tricked by skips, either manual or caused by skip_blank().</li>
<li>
<code>(unlabeled)</code> (<code>(float, float, [(string*string)], [(string*string)], source, source)-&gt;source</code>): Transition function, composing from the end of a track and the next track. It also takes the power of the signal before and after the transition, and the metadata.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>soundtouch</h5>
<pre class="syntax ">(?id:string, ?rate:'a, ?tempo:'b, ?pitch:'c,
 source)-&gt;source where 'a, 'b,
 'c is either float or ()-&gt;float</pre>
<p>
WARNING: This is only EXPERIMENTAL!
</p>
<p>
Change the rate, the tempo or the pitch of the sound.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>rate</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>1.</code>)</li>
<li>
<code>tempo</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>1.</code>)</li>
<li>
<code>pitch</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>1.</code>)</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>stereo.ms.decode</h5>
<pre class="syntax ">(?id:string, ?width:float, source)-&gt;source</pre>
<p>
Decode mid+side stereo (M/S) to left+right stereo.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>width</code> (<code>float</code> &ndash; defaults to <code>1.</code>): Width of the stereo field.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>stereo.ms.encode</h5>
<pre class="syntax ">(?id:string, source)-&gt;source</pre>
<p>
Encode left+right stereo to mid+side stereo (M/S).
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>stereo.pan</h5>
<pre class="syntax ">(?id:string, ?pan:'a, ?field:'b,
 source)-&gt;source where 'a, 'b is either float or ()
 -&gt;float</pre>
<p>
Pan a stereo sound.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>pan</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>0.</code>): Pan ranges between -1 and 1.</li>
<li>
<code>field</code> (<code>anything that is either float or ()-&gt;float</code> &ndash; defaults to <code>90.</code>): Field width in degrees (between 0 and 90).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>substract</h5>
<pre class="syntax ">(?id:string, source, source)-&gt;source</pre>
<p>
Compute the difference y-x of two sources y and x.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>): y</li>
<li>
<code>(unlabeled)</code> (<code>source</code>): x</li>
</ul>
<h5>swap</h5>
<pre class="syntax ">(?id:string, ?chan1:int, ?chan2:int, source)
 -&gt;source</pre>
<p>
swap two channels
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>chan1</code> (<code>int</code> &ndash; defaults to <code>0</code>): Channel one</li>
<li>
<code>chan2</code> (<code>int</code> &ndash; defaults to <code>1</code>): Channel two</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h3><a name="SourceSoundSynthesis">Source / Sound Synthesis</a></h3>
<h5>synth.all.hammond</h5>
<pre class="syntax ">(?id:string, ?attack:float, ?decay:float,
 ?sustain:float, ?release:float, source)-&gt;source</pre>
<p>
Hammond synthsizer. It creates one synthesizer for each channel.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>attack</code> (<code>float</code> &ndash; defaults to <code>0.02</code>): Envelope attack (in seconds).</li>
<li>
<code>decay</code> (<code>float</code> &ndash; defaults to <code>0.01</code>): Envelope decay (in seconds).</li>
<li>
<code>sustain</code> (<code>float</code> &ndash; defaults to <code>0.9</code>): Envelope sustain level.</li>
<li>
<code>release</code> (<code>float</code> &ndash; defaults to <code>0.01</code>): Envelope release (in seconds).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>synth.all.saw</h5>
<pre class="syntax ">(?id:string, ?attack:float, ?decay:float,
 ?sustain:float, ?release:float, source)-&gt;source</pre>
<p>
Saw synthesizer. It creates one synthesizer for each channel.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>attack</code> (<code>float</code> &ndash; defaults to <code>0.02</code>): Envelope attack (in seconds).</li>
<li>
<code>decay</code> (<code>float</code> &ndash; defaults to <code>0.01</code>): Envelope decay (in seconds).</li>
<li>
<code>sustain</code> (<code>float</code> &ndash; defaults to <code>0.9</code>): Envelope sustain level.</li>
<li>
<code>release</code> (<code>float</code> &ndash; defaults to <code>0.01</code>): Envelope release (in seconds).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>synth.all.sine</h5>
<pre class="syntax ">(?id:string, ?attack:float, ?decay:float,
 ?sustain:float, ?release:float, source)-&gt;source</pre>
<p>
Sine synthesizer. It creates one synthesizer for each channel.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>attack</code> (<code>float</code> &ndash; defaults to <code>0.02</code>): Envelope attack (in seconds).</li>
<li>
<code>decay</code> (<code>float</code> &ndash; defaults to <code>0.01</code>): Envelope decay (in seconds).</li>
<li>
<code>sustain</code> (<code>float</code> &ndash; defaults to <code>0.9</code>): Envelope sustain level.</li>
<li>
<code>release</code> (<code>float</code> &ndash; defaults to <code>0.01</code>): Envelope release (in seconds).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>synth.all.square</h5>
<pre class="syntax ">(?id:string, ?attack:float, ?decay:float,
 ?sustain:float, ?release:float, source)-&gt;source</pre>
<p>
Square synthesizer. It creates one synthesizer for each channel.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>attack</code> (<code>float</code> &ndash; defaults to <code>0.02</code>): Envelope attack (in seconds).</li>
<li>
<code>decay</code> (<code>float</code> &ndash; defaults to <code>0.01</code>): Envelope decay (in seconds).</li>
<li>
<code>sustain</code> (<code>float</code> &ndash; defaults to <code>0.9</code>): Envelope sustain level.</li>
<li>
<code>release</code> (<code>float</code> &ndash; defaults to <code>0.01</code>): Envelope release (in seconds).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>synth.hammond</h5>
<pre class="syntax ">(?id:string, ?channel:int, ?volume:float,
 ?attack:float, ?decay:float, ?sustain:float,
 ?release:float, source)-&gt;source</pre>
<p>
Hammond synthsizer.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>channel</code> (<code>int</code> &ndash; defaults to <code>0</code>): MIDI channel to handle.</li>
<li>
<code>volume</code> (<code>float</code> &ndash; defaults to <code>0.3</code>): Initial volume.</li>
<li>
<code>attack</code> (<code>float</code> &ndash; defaults to <code>0.02</code>): Envelope attack (in seconds).</li>
<li>
<code>decay</code> (<code>float</code> &ndash; defaults to <code>0.01</code>): Envelope decay (in seconds).</li>
<li>
<code>sustain</code> (<code>float</code> &ndash; defaults to <code>0.9</code>): Envelope sustain level.</li>
<li>
<code>release</code> (<code>float</code> &ndash; defaults to <code>0.05</code>): Envelope release (in seconds).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>synth.saw</h5>
<pre class="syntax ">(?id:string, ?channel:int, ?volume:float,
 ?attack:float, ?decay:float, ?sustain:float,
 ?release:float, source)-&gt;source</pre>
<p>
Saw synthesizer.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>channel</code> (<code>int</code> &ndash; defaults to <code>0</code>): MIDI channel to handle.</li>
<li>
<code>volume</code> (<code>float</code> &ndash; defaults to <code>0.3</code>): Initial volume.</li>
<li>
<code>attack</code> (<code>float</code> &ndash; defaults to <code>0.02</code>): Envelope attack (in seconds).</li>
<li>
<code>decay</code> (<code>float</code> &ndash; defaults to <code>0.01</code>): Envelope decay (in seconds).</li>
<li>
<code>sustain</code> (<code>float</code> &ndash; defaults to <code>0.9</code>): Envelope sustain level.</li>
<li>
<code>release</code> (<code>float</code> &ndash; defaults to <code>0.05</code>): Envelope release (in seconds).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>synth.sine</h5>
<pre class="syntax ">(?id:string, ?channel:int, ?volume:float,
 ?attack:float, ?decay:float, ?sustain:float,
 ?release:float, source)-&gt;source</pre>
<p>
Sine synthesizer.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>channel</code> (<code>int</code> &ndash; defaults to <code>0</code>): MIDI channel to handle.</li>
<li>
<code>volume</code> (<code>float</code> &ndash; defaults to <code>0.3</code>): Initial volume.</li>
<li>
<code>attack</code> (<code>float</code> &ndash; defaults to <code>0.02</code>): Envelope attack (in seconds).</li>
<li>
<code>decay</code> (<code>float</code> &ndash; defaults to <code>0.01</code>): Envelope decay (in seconds).</li>
<li>
<code>sustain</code> (<code>float</code> &ndash; defaults to <code>0.9</code>): Envelope sustain level.</li>
<li>
<code>release</code> (<code>float</code> &ndash; defaults to <code>0.05</code>): Envelope release (in seconds).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>synth.square</h5>
<pre class="syntax ">(?id:string, ?channel:int, ?volume:float,
 ?attack:float, ?decay:float, ?sustain:float,
 ?release:float, source)-&gt;source</pre>
<p>
Square synthesizer.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>channel</code> (<code>int</code> &ndash; defaults to <code>0</code>): MIDI channel to handle.</li>
<li>
<code>volume</code> (<code>float</code> &ndash; defaults to <code>0.3</code>): Initial volume.</li>
<li>
<code>attack</code> (<code>float</code> &ndash; defaults to <code>0.02</code>): Envelope attack (in seconds).</li>
<li>
<code>decay</code> (<code>float</code> &ndash; defaults to <code>0.01</code>): Envelope decay (in seconds).</li>
<li>
<code>sustain</code> (<code>float</code> &ndash; defaults to <code>0.9</code>): Envelope sustain level.</li>
<li>
<code>release</code> (<code>float</code> &ndash; defaults to <code>0.05</code>): Envelope release (in seconds).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h3><a name="SourceTrackProcessing">Source / Track Processing</a></h3>
<h5>append</h5>
<pre class="syntax ">(?id:string, ?merge:bool, ?insert_missing:bool,
 source, (([(string*string)])-&gt;source))-&gt;source</pre>
<p>
Append an extra track to every track. Set the metadata 'liq_append' to 'false' to inhibit appending on one track.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>merge</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Merge the track with its appended track.</li>
<li>
<code>insert_missing</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Treat track beginnings without metadata as having empty one.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
<li>
<code>(unlabeled)</code> (<code>([(string*string)])-&gt;source</code>): Given the metadata, build the source producing the track to append. This source is allowed to fail (produce nothing) if no relevant track is to be appended.</li>
</ul>
<h5>at</h5>
<pre class="syntax ">((()-&gt;bool), source)-&gt;source</pre>
<p>
Restrict a source to play only when a predicate is true.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>()-&gt;bool</code>): The predicate, typically a time interval such as <code>{10h-10h30}</code>.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>clear_metadata</h5>
<pre class="syntax ">(source)-&gt;source</pre>
<p>
Removes all metadata coming from a source
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>crossfade</h5>
<pre class="syntax ">(~start_next:float, ~fade_in:float, ~fade_out:float,
 source)-&gt;source</pre>
<p>
Simple crossfade.
</p>
<ul>
<li>
<code>start_next</code> (<code>float</code>): Duration in seconds of the crossed end of track.</li>
<li>
<code>fade_in</code> (<code>float</code>): Duration of the fade in for next track</li>
<li>
<code>fade_out</code> (<code>float</code>): Duration of the fade out for previous track</li>
<li>
<code>(unlabeled)</code> (<code>source</code>): The source to use</li>
</ul>
<h5>delay</h5>
<pre class="syntax ">(?id:string, float, source)-&gt;source</pre>
<p>
Prevents the child from being ready again too fast after a end of track
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>float</code>): The source won't be ready less than this amount of seconds after any end of track</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>eat_blank</h5>
<pre class="syntax ">(?id:string, ?at_beginning:bool, ?threshold:float,
 ?length:float, source)-&gt;source</pre>
<p>
Eat blanks, i.e., drop the contents of the stream until it is not blank anymore.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>at_beginning</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Only eat at the beginning of a track.</li>
<li>
<code>threshold</code> (<code>float</code> &ndash; defaults to <code>-40.</code>): Power in decibels under which the stream is considered silent.</li>
<li>
<code>length</code> (<code>float</code> &ndash; defaults to <code>20.</code>): Maximum silence length allowed, in seconds.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>fallback</h5>
<pre class="syntax ">(?id:string, ?track_sensitive:bool,
 ?replay_metadata:bool, ?before:float,
 ?transitions:[(source, source)-&gt;source], [source])
 -&gt;source</pre>
<p>
At the beginning of each track, select the first ready child.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>track_sensitive</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Re-select only on end of tracks.</li>
<li>
<code>replay_metadata</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Replay the last metadata of a child when switching to it in the middle of a track.</li>
<li>
<code>before</code> (<code>float</code> &ndash; defaults to <code>0.</code>): EXPERIMENTAL: for track_sensitive switches, trigger transitions before the end of track.</li>
<li>
<code>transitions</code> (<code>[(source, source)-&gt;source]</code> &ndash; defaults to <code>[  ]</code>): Transition functions, padded with <code>fun (x,y) -&gt; y</code> functions.</li>
<li>
<code>(unlabeled)</code> (<code>[source]</code>): Select the first ready source in this list.</li>
</ul>
<h5>fallback.skip</h5>
<pre class="syntax ">(~input:source, source)-&gt;source</pre>
<p>
Special track insensitive fallback that
always skip current song before switching.
</p>
<ul>
<li>
<code>input</code> (<code>source</code>): The input source</li>
<li>
<code>(unlabeled)</code> (<code>source</code>): The fallback source</li>
</ul>
<h5>map_metadata</h5>
<pre class="syntax ">(?id:string,
 (([(string*string)])-&gt;[(string*string)]),
 ?update:bool, ?strip:bool, ?insert_missing:bool,
 source)-&gt;source</pre>
<p>
Rewrite metadata on the fly using a function.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>([(string*string)])-&gt;[(string*string)]</code>): A function that returns new metadata.</li>
<li>
<code>update</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Only update metadata. If false, only returned values will be set as metadata.</li>
<li>
<code>strip</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Completly remove empty metadata. Operates on both empty values and empty metadata chunk.</li>
<li>
<code>insert_missing</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Treat track beginnings without metadata as having empty ones. The operational order is: create empty if needed, map and strip if enabled.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>on_blank</h5>
<pre class="syntax ">(?id:string, (()-&gt;unit), ?on_noise:(()-&gt;unit),
 ?threshold:float, ?length:float, source)-&gt;source</pre>
<p>
Calls a given handler when detecting a blank.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>()-&gt;unit</code>): Handler called when blank is detected.</li>
<li>
<code>on_noise</code> (<code>()-&gt;unit</code> &ndash; defaults to <code>{()}</code>): Handler called when noise is detected.</li>
<li>
<code>threshold</code> (<code>float</code> &ndash; defaults to <code>-40.</code>): Power in decibels under which the stream is considered silent.</li>
<li>
<code>length</code> (<code>float</code> &ndash; defaults to <code>20.</code>): Maximum silence length allowed, in seconds.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>on_end</h5>
<pre class="syntax ">(?id:string, ?delay:float, ((float,
 [(string*string)])-&gt;unit), source)-&gt;source</pre>
<p>
Call a given handler when there is less than a given amount of time remaining before then end of track.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>delay</code> (<code>float</code> &ndash; defaults to <code>5.</code>): Execute handler when remaining time is less or equal to this value.</li>
<li>
<code>(unlabeled)</code> (<code>(float, [(string*string)])-&gt;unit</code>): Function to execute. First argument is the remaining time, second is the latest metadata.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>on_metadata</h5>
<pre class="syntax ">(?id:string, (([(string*string)])-&gt;unit), source)
 -&gt;source</pre>
<p>
Call a given handler on metadata packets.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>([(string*string)])-&gt;unit</code>): Function called on every metadata packet in the stream. It should be fast because it is ran in the main thread.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>on_track</h5>
<pre class="syntax ">(?id:string, (([(string*string)])-&gt;unit), source)
 -&gt;source</pre>
<p>
Call a given handler on new tracks.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>([(string*string)])-&gt;unit</code>): Function called on every beginning of track in the stream, with the corresponding metadata as argument. If there is no metadata at the beginning of track, the empty list is passed. That function should be fast because it is ran in the main thread.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>once</h5>
<pre class="syntax ">(source)-&gt;source</pre>
<p>
Creates a source that plays only one track of the input source.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>source</code>): The input source.</li>
</ul>
<h5>prepend</h5>
<pre class="syntax ">(?id:string, ?merge:bool, source,
 (([(string*string)])-&gt;source))-&gt;source</pre>
<p>
Prepend an extra track before every track. Set the metadata 'liq_prepend' to 'false' to inhibit prepending on one track.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>merge</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Merge the track with its appended track.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
<li>
<code>(unlabeled)</code> (<code>([(string*string)])-&gt;source</code>): Given the metadata, build the source producing the track to prepend. This source is allowed to fail (produce nothing) if no relevant track is to be appended. However, success must be immediate.</li>
</ul>
<h5>random</h5>
<pre class="syntax ">(?id:string, ?track_sensitive:bool,
 ?replay_metadata:bool, ?before:float,
 ?transitions:[(source, source)-&gt;source],
 ?weights:[int], [source])-&gt;source</pre>
<p>
At the beginning of every track, select a random ready child.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>track_sensitive</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Re-select only on end of tracks.</li>
<li>
<code>replay_metadata</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Replay the last metadata of a child when switching to it in the middle of a track.</li>
<li>
<code>before</code> (<code>float</code> &ndash; defaults to <code>0.</code>): EXPERIMENTAL: for track_sensitive switches, trigger transitions before the end of track.</li>
<li>
<code>transitions</code> (<code>[(source, source)-&gt;source]</code> &ndash; defaults to <code>[  ]</code>): Transition functions, padded with <code>fun (x,y) -&gt; y</code> functions.</li>
<li>
<code>weights</code> (<code>[int]</code> &ndash; defaults to <code>[  ]</code>): Weights of the children (padded with 1), defining for each child the probability that it is selected.</li>
<li>
<code>(unlabeled)</code> (<code>[source]</code>)</li>
</ul>
<h5>rewrite_metadata</h5>
<pre class="syntax ">([(string*string)], ?insert_missing:bool,
 ?update:bool, ?strip:bool, source)-&gt;source</pre>
<p>
Rewrite metadata on the fly using a list of (target,rules).
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>[(string*string)]</code>): list of (target,value) rewriting rules</li>
<li>
<code>insert_missing</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Treat track beginnings without metadata as having empty ones. The operational order is: create empty if needed, map and strip if enabled.</li>
<li>
<code>update</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Only update metadata. If false, only returned values will be set as metadata.</li>
<li>
<code>strip</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Completly remove empty metadata. Operates on both empty values and empty metadata chunk.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>rotate</h5>
<pre class="syntax ">(?id:string, ?track_sensitive:bool,
 ?replay_metadata:bool, ?before:float,
 ?transitions:[(source, source)-&gt;source],
 ?weights:[int], [source])-&gt;source</pre>
<p>
Rotate between the sources.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>track_sensitive</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Re-select only on end of tracks.</li>
<li>
<code>replay_metadata</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Replay the last metadata of a child when switching to it in the middle of a track.</li>
<li>
<code>before</code> (<code>float</code> &ndash; defaults to <code>0.</code>): EXPERIMENTAL: for track_sensitive switches, trigger transitions before the end of track.</li>
<li>
<code>transitions</code> (<code>[(source, source)-&gt;source]</code> &ndash; defaults to <code>[  ]</code>): Transition functions, padded with <code>fun (x,y) -&gt; y</code> functions.</li>
<li>
<code>weights</code> (<code>[int]</code> &ndash; defaults to <code>[  ]</code>): Weights of the children (padded with 1), defining for each child how many tracks are played from it per round, if that many are actually available.</li>
<li>
<code>(unlabeled)</code> (<code>[source]</code>)</li>
</ul>
<h5>say_metadata</h5>
<pre class="syntax ">(source, ?pattern:string)-&gt;source</pre>
<p>
Append speech-synthesized tracks reading the metadata.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>source</code>): The source to use</li>
<li>
<code>pattern</code> (<code>string</code> &ndash; defaults to <code>&quot;say:$(if $(artist),\&quot;It was $(artist)$(if $(title),\\\&quot;, $(title)\\\&quot;).\&quot;)&quot;</code>): Pattern to use</li>
</ul>
<h5>sequence</h5>
<pre class="syntax ">(?id:string, ?merge:bool, [source])-&gt;source</pre>
<p>
Play only one track of every successive source, except for the last one which is played as much as available.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>merge</code> (<code>bool</code> &ndash; defaults to <code>false</code>)</li>
<li>
<code>(unlabeled)</code> (<code>[source]</code>)</li>
</ul>
<h5>skip_blank</h5>
<pre class="syntax ">(?id:string, ?threshold:float, ?length:float,
 source)-&gt;source</pre>
<p>
Skip track when detecting a blank.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>threshold</code> (<code>float</code> &ndash; defaults to <code>-40.</code>): Power in decibels under which the stream is considered silent.</li>
<li>
<code>length</code> (<code>float</code> &ndash; defaults to <code>20.</code>): Maximum silence length allowed, in seconds.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>smart_crossfade</h5>
<pre class="syntax ">(?start_next:float, ?fade_in:float, ?fade_out:float,
 ?default:((source, source)-&gt;source), ?high:float,
 ?medium:float, ?margin:float, ?width:float,
 ?conservative:bool, source)-&gt;source</pre>
<p>
Crossfade between tracks, taking the respective volume levels into account in
the choice of the transition.
</p>
<ul>
<li>
<code>start_next</code> (<code>float</code> &ndash; defaults to <code>5.</code>): Crossing duration, if any.</li>
<li>
<code>fade_in</code> (<code>float</code> &ndash; defaults to <code>3.</code>): Fade-in duration, if any.</li>
<li>
<code>fade_out</code> (<code>float</code> &ndash; defaults to <code>3.</code>): Fade-out duration, if any.</li>
<li>
<code>default</code> (<code>(source, source)-&gt;source</code> &ndash; defaults to <code>&lt;fun&gt;</code>): Default transition when no rule can apply (default: sequence)</li>
<li>
<code>high</code> (<code>float</code> &ndash; defaults to <code>-15.</code>): Value, in dB, for loud sound level</li>
<li>
<code>medium</code> (<code>float</code> &ndash; defaults to <code>-32.</code>): Value, in dB, for medium sound level</li>
<li>
<code>margin</code> (<code>float</code> &ndash; defaults to <code>4.</code>): Margin to detect sources that have too different sound level</li>
<li>
<code>width</code> (<code>float</code> &ndash; defaults to <code>2.</code>): Width of the volume analysis window.</li>
<li>
<code>conservative</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Always prepare for a premature end-of-track.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>): The input source.</li>
</ul>
<h5>smooth_add</h5>
<pre class="syntax ">(?delay:float, ?p:float, ~normal:source,
 ~special:source)-&gt;source</pre>
<p>
Mixes two streams, with faded transitions between the state when only the
normal stream is available and when the special stream gets added on top of
it.
</p>
<ul>
<li>
<code>delay</code> (<code>float</code> &ndash; defaults to <code>0.5</code>): Delay before starting the special source.</li>
<li>
<code>p</code> (<code>float</code> &ndash; defaults to <code>0.2</code>): Portion of amplitude of the normal source in the mix.</li>
<li>
<code>normal</code> (<code>source</code>): The normal source, which could be called the carrier too.</li>
<li>
<code>special</code> (<code>source</code>): The special source.</li>
</ul>
<h5>store_metadata</h5>
<pre class="syntax ">(?id:string, ?size:int, source)-&gt;source</pre>
<p>
Keep track of the last N metadata packets in the stream, and make the history available via a server command.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>size</code> (<code>int</code> &ndash; defaults to <code>10</code>): Size of the history</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>strip_blank</h5>
<pre class="syntax ">(?id:string, ?threshold:float, ?length:float,
 source)-&gt;source</pre>
<p>
Make the source unavailable when it is streaming blank.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>threshold</code> (<code>float</code> &ndash; defaults to <code>-40.</code>): Power in decibels under which the stream is considered silent.</li>
<li>
<code>length</code> (<code>float</code> &ndash; defaults to <code>20.</code>): Maximum silence length allowed, in seconds.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>switch</h5>
<pre class="syntax ">(?id:string, ?track_sensitive:bool,
 ?replay_metadata:bool, ?before:float,
 ?transitions:[(source, source)-&gt;source],
 ?single:[bool], [((()-&gt;bool)*source)])-&gt;source</pre>
<p>
At the beginning of a track, select the first source whose predicate is true.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>track_sensitive</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Re-select only on end of tracks.</li>
<li>
<code>replay_metadata</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Replay the last metadata of a child when switching to it in the middle of a track.</li>
<li>
<code>before</code> (<code>float</code> &ndash; defaults to <code>0.</code>): EXPERIMENTAL: for track_sensitive switches, trigger transitions before the end of track.</li>
<li>
<code>transitions</code> (<code>[(source, source)-&gt;source]</code> &ndash; defaults to <code>[  ]</code>): Transition functions, padded with <code>fun (x,y) -&gt; y</code> functions.</li>
<li>
<code>single</code> (<code>[bool]</code> &ndash; defaults to <code>[  ]</code>): Forbid the selection of a branch for two tracks in a row. The empty list stands for <code>[false,...,false]</code>.</li>
<li>
<code>(unlabeled)</code> (<code>[((()-&gt;bool)*source)]</code>): Sources with the predicate telling when they can be played.</li>
</ul>
<h3><a name="SourceVideoProcessing">Source / Video Processing</a></h3>
<h5>video.fade.final</h5>
<pre class="syntax ">(?id:string, ?duration:float, ?transition:string,
 ?type:string, source)-&gt;source</pre>
<p>
Fade a stream to black.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>3.</code>): Duration of the fading. This value can be set on a per-file basis using the metadata field passed as override.</li>
<li>
<code>transition</code> (<code>string</code> &ndash; defaults to <code>&quot;fade&quot;</code>): Kind of transition (fade|slide_left|slide_right|slide_up|slide_down|grow|disc|random).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>video.fade.in</h5>
<pre class="syntax ">(?id:string, ?override:string, ?duration:float,
 ?transition:string, ?type:string, source)-&gt;source</pre>
<p>
Fade the beginning of tracks. Metadata 'liq_video_fade_in' can be used to set the duration for a specific track (float in seconds).
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>override</code> (<code>string</code> &ndash; defaults to <code>&quot;liq_video_fade_in&quot;</code>): Metadata field which, if present and containing a float, overrides the 'duration' parameter for current track.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>3.</code>): Duration of the fading. This value can be set on a per-file basis using the metadata field passed as override.</li>
<li>
<code>transition</code> (<code>string</code> &ndash; defaults to <code>&quot;fade&quot;</code>): Kind of transition (fade|slide_left|slide_right|slide_up|slide_down|grow|disc|random).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>video.fade.initial</h5>
<pre class="syntax ">(?id:string, ?duration:float, ?transition:string,
 ?type:string, source)-&gt;source</pre>
<p>
Fade the beginning of a stream.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>3.</code>): Duration of the fading. This value can be set on a per-file basis using the metadata field passed as override.</li>
<li>
<code>transition</code> (<code>string</code> &ndash; defaults to <code>&quot;fade&quot;</code>): Kind of transition (fade|slide_left|slide_right|slide_up|slide_down|grow|disc|random).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>video.fade.out</h5>
<pre class="syntax ">(?id:string, ?override:string, ?duration:float,
 ?transition:string, ?type:string, source)-&gt;source</pre>
<p>
Fade the end of tracks. Metadata 'liq_video_fade_out' can be used to set the duration for a specific track (float in seconds).
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>override</code> (<code>string</code> &ndash; defaults to <code>&quot;liq_video_fade_out&quot;</code>): Metadata field which, if present and containing a float, overrides the 'duration' parameter for current track.</li>
<li>
<code>duration</code> (<code>float</code> &ndash; defaults to <code>3.</code>): Duration of the fading. This value can be set on a per-file basis using the metadata field passed as override.</li>
<li>
<code>transition</code> (<code>string</code> &ndash; defaults to <code>&quot;fade&quot;</code>): Kind of transition (fade|slide_left|slide_right|slide_up|slide_down|grow|disc|random).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>video.fill</h5>
<pre class="syntax ">(?id:string, ?color:int, source)-&gt;source</pre>
<p>
Fill frame with a color.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>color</code> (<code>int</code> &ndash; defaults to <code>0</code>): Color to fill the image with.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>video.greyscale</h5>
<pre class="syntax ">(?id:string, source)-&gt;source</pre>
<p>
Convert video to greyscale.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>video.invert</h5>
<pre class="syntax ">(?id:string, source)-&gt;source</pre>
<p>
Invert video.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>video.lomo</h5>
<pre class="syntax ">(?id:string, source)-&gt;source</pre>
<p>
Emulate the “Lomo effect”.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>video.opacity</h5>
<pre class="syntax ">(?id:string, float, source)-&gt;source</pre>
<p>
Scale opacity of video.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>float</code>): Coefficient to scale opacity with.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>video.opacity.blur</h5>
<pre class="syntax ">(?id:string, source)-&gt;source</pre>
<p>
Blur opacity of video.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>video.rotate</h5>
<pre class="syntax ">(?id:string, ?angle:float, ?speed:float, source)
 -&gt;source</pre>
<p>
Rotate video.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>angle</code> (<code>float</code> &ndash; defaults to <code>0.</code>): Initial angle in radians.</li>
<li>
<code>speed</code> (<code>float</code> &ndash; defaults to <code>3.1416</code>): Rotation speed in radians per sec.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>video.scale</h5>
<pre class="syntax ">(?id:string, ?coef:float, ?coef_x:float,
 ?coef_y:float, ?offset_x:int, ?offset_y:int,
 source)-&gt;source</pre>
<p>
Scale and translate video.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>coef</code> (<code>float</code> &ndash; defaults to <code>1.</code>): Scaling coefficient in both directions.</li>
<li>
<code>coef_x</code> (<code>float</code> &ndash; defaults to <code>1.</code>): x scaling</li>
<li>
<code>coef_y</code> (<code>float</code> &ndash; defaults to <code>1.</code>): y scaling</li>
<li>
<code>offset_x</code> (<code>int</code> &ndash; defaults to <code>1</code>): x offset</li>
<li>
<code>offset_y</code> (<code>int</code> &ndash; defaults to <code>1</code>): y offset</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>video.sepia</h5>
<pre class="syntax ">(?id:string, source)-&gt;source</pre>
<p>
Convert video to sepia.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>video.tile</h5>
<pre class="syntax ">(?id:string, ?normalize:bool, ?weights:[int],
 ?proportional:bool, [source])-&gt;source</pre>
<p>
Tile sources (same as add but produces tiles of videos).
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>normalize</code> (<code>bool</code> &ndash; defaults to <code>true</code>)</li>
<li>
<code>weights</code> (<code>[int]</code> &ndash; defaults to <code>[  ]</code>): Relative weight of the sources in the sum. The empty list stands for the homogeneous distribution.</li>
<li>
<code>proportional</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Scale preserving the proportions.</li>
<li>
<code>(unlabeled)</code> (<code>[source]</code>)</li>
</ul>
<h5>video.transparent</h5>
<pre class="syntax ">(?id:string, ?precision:float, ?color:int, source)
 -&gt;source</pre>
<p>
Set a color to be transparent.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>precision</code> (<code>float</code> &ndash; defaults to <code>0.</code>): Precision in color matching (0. means match precisely the color and 1. means match every color).</li>
<li>
<code>color</code> (<code>int</code> &ndash; defaults to <code>0</code>): Color which should be transparent (in 0xRRGGBB format).</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h3><a name="SourceVisualization">Source / Visualization</a></h3>
<h5>video.volume</h5>
<pre class="syntax ">(?id:string, source)-&gt;source</pre>
<p>
Graphical visualization of the sound.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>visu.glvolume</h5>
<pre class="syntax ">(?id:string, source)-&gt;source</pre>
<p>
Graphical visualization of the volume using openGL.
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>vumeter</h5>
<pre class="syntax ">(?id:string, ?scroll:bool, source)-&gt;source</pre>
<p>
VU meter (display the volume).
</p>
<ul>
<li>
<code>id</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Force the value of the source ID.</li>
<li>
<code>scroll</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Scroll.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h3><a name="Bool">Bool</a></h3>
<h5>!=</h5>
<pre class="syntax ">('a, 'a)-&gt;bool where 'a is an orderable type</pre>
<p>
Comparison of comparable values.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>anything that is an orderable type</code>)</li>
<li>
<code>(unlabeled)</code> (<code>anything that is an orderable type</code>)</li>
</ul>
<h5>&lt;</h5>
<pre class="syntax ">('a, 'a)-&gt;bool where 'a is an orderable type</pre>
<p>
Comparison of comparable values.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>anything that is an orderable type</code>)</li>
<li>
<code>(unlabeled)</code> (<code>anything that is an orderable type</code>)</li>
</ul>
<h5>&lt;=</h5>
<pre class="syntax ">('a, 'a)-&gt;bool where 'a is an orderable type</pre>
<p>
Comparison of comparable values.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>anything that is an orderable type</code>)</li>
<li>
<code>(unlabeled)</code> (<code>anything that is an orderable type</code>)</li>
</ul>
<h5>==</h5>
<pre class="syntax ">('a, 'a)-&gt;bool where 'a is an orderable type</pre>
<p>
Comparison of comparable values.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>anything that is an orderable type</code>)</li>
<li>
<code>(unlabeled)</code> (<code>anything that is an orderable type</code>)</li>
</ul>
<h5>&gt;</h5>
<pre class="syntax ">('a, 'a)-&gt;bool where 'a is an orderable type</pre>
<p>
Comparison of comparable values.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>anything that is an orderable type</code>)</li>
<li>
<code>(unlabeled)</code> (<code>anything that is an orderable type</code>)</li>
</ul>
<h5>&gt;=</h5>
<pre class="syntax ">('a, 'a)-&gt;bool where 'a is an orderable type</pre>
<p>
Comparison of comparable values.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>anything that is an orderable type</code>)</li>
<li>
<code>(unlabeled)</code> (<code>anything that is an orderable type</code>)</li>
</ul>
<h5>and</h5>
<pre class="syntax ">(bool, bool)-&gt;bool</pre>
<p>
Return the conjunction of its arguments
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>bool</code>)</li>
<li>
<code>(unlabeled)</code> (<code>bool</code>)</li>
</ul>
<h5>not</h5>
<pre class="syntax ">(bool)-&gt;bool</pre>
<p>
Returns the negation of its argument.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>bool</code>)</li>
</ul>
<h5>or</h5>
<pre class="syntax ">(bool, bool)-&gt;bool</pre>
<p>
Return the disjunction of its arguments
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>bool</code>)</li>
<li>
<code>(unlabeled)</code> (<code>bool</code>)</li>
</ul>
<h5>random.bool</h5>
<pre class="syntax ">()-&gt;bool</pre>
<p>
Generate a random value.
</p>
<h3><a name="Control">Control</a></h3>
<h5>add_timeout</h5>
<pre class="syntax ">(?fast:bool, float, (()-&gt;float))-&gt;unit</pre>
<p>
Call a function in N seconds. If the result of the function is a positive or null integer, the task will be scheduled after this amount of time (in seconds.)
</p>
<ul>
<li>
<code>fast</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Set to <code>false</code> if the execution of the code can take long in order to lower its priority below that of request resolutions and fast timeouts. This is only effective if you set a dedicated queue for fast tasks, see the “scheduler” settings for more details.</li>
<li>
<code>(unlabeled)</code> (<code>float</code>)</li>
<li>
<code>(unlabeled)</code> (<code>()-&gt;float</code>)</li>
</ul>
<h5>ignore</h5>
<pre class="syntax ">('a)-&gt;unit</pre>
<p>
Convert anything to unit, preventing warnings.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>'a</code>)</li>
</ul>
<h3><a name="Deprecated">Deprecated</a></h3>
<h5>request</h5>
<pre class="syntax ">(string)-&gt;request</pre>
<p>
Backward compatible function for request.create().
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h3><a name="Interaction">Interaction</a></h3>
<h5>audioscrobbler.nowplaying</h5>
<pre class="syntax ">(~user:string, ~password:string, ?host:string,
 ?port:int, ?length:bool, [(string*string)])-&gt;unit</pre>
<p>
Submit a now playing song using the audioscrobbler protocol.
</p>
<ul>
<li>
<code>user</code> (<code>string</code>)</li>
<li>
<code>password</code> (<code>string</code>)</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;post.audioscrobbler.com&quot;</code>): Host for audioscrobbling submissions.</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>80</code>): Port for audioscrobbling submissions.</li>
<li>
<code>length</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Try to submit length information. This operation can be CPU intensive. Value forced to true when used with the “user” source type.</li>
<li>
<code>(unlabeled)</code> (<code>[(string*string)]</code>)</li>
</ul>
<h5>audioscrobbler.submit</h5>
<pre class="syntax ">(?source:string, ~user:string, ~password:string,
 ?host:string, ?port:int, ?length:bool,
 [(string*string)])-&gt;unit</pre>
<p>
Submit a played song using the audioscrobbler protocol.
</p>
<ul>
<li>
<code>source</code> (<code>string</code> &ndash; defaults to <code>&quot;broadcast&quot;</code>): Source for tracks. Should be one of: “broadcast”, “user”, “recommendation” or “unknown”. Since liquidsoap is intented for radio broadcasting, this is the default. Sources other than user don't need duration to be set.</li>
<li>
<code>user</code> (<code>string</code>)</li>
<li>
<code>password</code> (<code>string</code>)</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;post.audioscrobbler.com&quot;</code>): Host for audioscrobbling submissions.</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>80</code>): Port for audioscrobbling submissions.</li>
<li>
<code>length</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Try to submit length information. This operation can be CPU intensive. Value forced to true when used with the “user” source type.</li>
<li>
<code>(unlabeled)</code> (<code>[(string*string)]</code>)</li>
</ul>
<h5>audioscrobbler.submit.full</h5>
<pre class="syntax ">(~user:string, ~password:string, ?host:string,
 ?port:int, ?source:string, ?length:bool,
 ?delay:float, ?force:bool, source)-&gt;source</pre>
<p>
Submit songs using audioscrobbler, respecting the full protocol:
First signal song as now playing when starting, and
then submit song when it ends.
</p>
<ul>
<li>
<code>user</code> (<code>string</code>)</li>
<li>
<code>password</code> (<code>string</code>)</li>
<li>
<code>host</code> (<code>string</code> &ndash; defaults to <code>&quot;post.audioscrobbler.com&quot;</code>)</li>
<li>
<code>port</code> (<code>int</code> &ndash; defaults to <code>80</code>)</li>
<li>
<code>source</code> (<code>string</code> &ndash; defaults to <code>&quot;broadcast&quot;</code>): Source for tracks. Should be one of: “broadcast”, “user”, “recommendation” or “unknown”. Since liquidsoap is intented for radio broadcasting, this is the default. Sources other than user don't need duration to be set.</li>
<li>
<code>length</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Try to submit length information. This operation can be CPU intensive. Value forced to true when used with the “user” source type.</li>
<li>
<code>delay</code> (<code>float</code> &ndash; defaults to <code>10.</code>): Submit song when there is only this delay left, in seconds. </li>
<li>
<code>force</code> (<code>bool</code> &ndash; defaults to <code>false</code>): If remaining time is null, the song will be assumed to be skipped or cuted, and not submitted. Set to zero to disable this behaviour.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>interactive.float</h5>
<pre class="syntax ">(string, float)-&gt;()-&gt;float</pre>
<p>
Read a float from an interactive input.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>float</code>)</li>
</ul>
<h5>interactive.string</h5>
<pre class="syntax ">(string, string)-&gt;()-&gt;string</pre>
<p>
Read a string from an interactive input.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>lastfm.nowplaying</h5>
<pre class="syntax ">(~user:string, ~password:string, ?length:bool,
 [(string*string)])-&gt;unit</pre>
<p>
Submit metadata to lastfm.fm using the audioscrobbler protocol (nowplaying mode).
</p>
<ul>
<li>
<code>user</code> (<code>string</code>)</li>
<li>
<code>password</code> (<code>string</code>)</li>
<li>
<code>length</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Try to submit length information. This operation can be CPU intensive. Value forced to true when used with the “user” source type.</li>
<li>
<code>(unlabeled)</code> (<code>[(string*string)]</code>)</li>
</ul>
<h5>lastfm.submit</h5>
<pre class="syntax ">(~user:string, ~password:string, ?source:string,
 ?length:bool, [(string*string)])-&gt;unit</pre>
<p>
Submit metadata to lastfm.fm using the audioscrobbler protocol.
</p>
<ul>
<li>
<code>user</code> (<code>string</code>)</li>
<li>
<code>password</code> (<code>string</code>)</li>
<li>
<code>source</code> (<code>string</code> &ndash; defaults to <code>&quot;broadcast&quot;</code>): Source for tracks. Should be one of: “broadcast”, “user”, “recommendation” or “unknown”. Since liquidsoap is intented for radio broadcasting, this is the default. Sources other than user don't need duration to be set.</li>
<li>
<code>length</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Try to submit length information. This operation can be CPU intensive. Value forced to true when used with the “user” source type.</li>
<li>
<code>(unlabeled)</code> (<code>[(string*string)]</code>)</li>
</ul>
<h5>lastfm.submit.full</h5>
<pre class="syntax ">(~user:string, ~password:string, ?source:string,
 ?length:bool, ?delay:float, ?force:bool, source)
 -&gt;source</pre>
<p>
Submit songs to lastfm using audioscrobbler, respecting the full protocol:
First signal song as now playing when starting, and
then submit song when it ends.
</p>
<ul>
<li>
<code>user</code> (<code>string</code>)</li>
<li>
<code>password</code> (<code>string</code>)</li>
<li>
<code>source</code> (<code>string</code> &ndash; defaults to <code>&quot;broadcast&quot;</code>): Source for tracks. Should be one of: “broadcast”, “user”, “recommendation” or “unknown”. Since liquidsoap is intented for radio broadcasting, this is the default. Sources other than user don't need duration to be set.</li>
<li>
<code>length</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Try to submit length information. This operation can be CPU intensive. Value forced to true when used with the “user” source type.</li>
<li>
<code>delay</code> (<code>float</code> &ndash; defaults to <code>10.</code>): Submit song when there is only this delay left, in seconds. If remaining time is less than this value, the song will be assumed to be skipped or cuted, and not submitted. Set to zero to disable this behaviour.</li>
<li>
<code>force</code> (<code>bool</code> &ndash; defaults to <code>false</code>): If remaining time is null, the song will be assumed to be skipped or cuted, and not submitted. Set to zero to disable this behaviour.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>librefm.nowplaying</h5>
<pre class="syntax ">(~user:string, ~password:string, ?length:bool,
 [(string*string)])-&gt;unit</pre>
<p>
Submit metadata to libre.fm using the audioscrobbler protocol (nowplaying mode).
</p>
<ul>
<li>
<code>user</code> (<code>string</code>)</li>
<li>
<code>password</code> (<code>string</code>)</li>
<li>
<code>length</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Try to submit length information. This operation can be CPU intensive. Value forced to true when used with the “user” source type.</li>
<li>
<code>(unlabeled)</code> (<code>[(string*string)]</code>)</li>
</ul>
<h5>librefm.submit</h5>
<pre class="syntax ">(~user:string, ~password:string, ?source:string,
 ?length:bool, [(string*string)])-&gt;unit</pre>
<p>
Submit metadata to libre.fm using the audioscrobbler protocol.
</p>
<ul>
<li>
<code>user</code> (<code>string</code>)</li>
<li>
<code>password</code> (<code>string</code>)</li>
<li>
<code>source</code> (<code>string</code> &ndash; defaults to <code>&quot;broadcast&quot;</code>): Source for tracks. Should be one of: “broadcast”, “user”, “recommendation” or “unknown”. Since liquidsoap is intented for radio broadcasting, this is the default. Sources other than user don't need duration to be set.</li>
<li>
<code>length</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Try to submit length information. This operation can be CPU intensive. Value forced to true when used with the “user” source type.</li>
<li>
<code>(unlabeled)</code> (<code>[(string*string)]</code>)</li>
</ul>
<h5>librefm.submit.full</h5>
<pre class="syntax ">(~user:string, ~password:string, ?source:string,
 ?length:bool, ?delay:float, ?force:bool, source)
 -&gt;source</pre>
<p>
Submit songs to librefm using audioscrobbler, respecting the full protocol:
First signal song as now playing when starting, and
then submit song when it ends.
</p>
<ul>
<li>
<code>user</code> (<code>string</code>)</li>
<li>
<code>password</code> (<code>string</code>)</li>
<li>
<code>source</code> (<code>string</code> &ndash; defaults to <code>&quot;broadcast&quot;</code>): Source for tracks. Should be one of: “broadcast”, “user”, “recommendation” or “unknown”. Since liquidsoap is intented for radio broadcasting, this is the default. Sources other than user don't need duration to be set.</li>
<li>
<code>length</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Try to submit length information. This operation can be CPU intensive. Value forced to true when used with the “user” source type.</li>
<li>
<code>delay</code> (<code>float</code> &ndash; defaults to <code>10.</code>): Submit song when there is only this delay left, in seconds. If remaining time is less than this value, the song will be assumed to be skipped or cuted, and not submitted. Set to zero to disable this behaviour.</li>
<li>
<code>force</code> (<code>bool</code> &ndash; defaults to <code>false</code>): If remaining time is null, the song will be assumed to be skipped or cuted, and not submitted. Set to zero to disable this behaviour.</li>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>print</h5>
<pre class="syntax ">(?newline:bool, 'a)-&gt;unit</pre>
<p>
Print on standard output.
</p>
<ul>
<li>
<code>newline</code> (<code>bool</code> &ndash; defaults to <code>true</code>): If true, a newline is added after displaying the value.</li>
<li>
<code>(unlabeled)</code> (<code>'a</code>)</li>
</ul>
<h3><a name="Liquidsoap">Liquidsoap</a></h3>
<h5>add_decoder</h5>
<pre class="syntax ">(string, ((string)-&gt;string))-&gt;unit</pre>
<p>
Register an external file decoder. The encoder should output in WAV format to his standard output (stdout).
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>): Format/decoder's name.</li>
<li>
<code>(unlabeled)</code> (<code>(string)-&gt;string</code>): Process to start. The function takes the filename as argument and returns the process to start.</li>
</ul>
<h5>add_metadata_resolver</h5>
<pre class="syntax ">(string, ((~format:string,
 string)-&gt;[(string*string)]))-&gt;unit</pre>
<p>
Register an external file metadata decoder.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>): Format/resolver's name.</li>
<li>
<code>(unlabeled)</code> (<code>(~format:string, string)-&gt;[(string*string)]</code>): Process to start. The function takes the format and filename as argument and returns a list of (name,value) fields.</li>
</ul>
<h5>add_protocol</h5>
<pre class="syntax ">(?temporary:bool, string, ((string,
 float)-&gt;[string]))-&gt;unit</pre>
<p>
Register a new protocol.
</p>
<ul>
<li>
<code>temporary</code> (<code>bool</code> &ndash; defaults to <code>false</code>): if true, file removed when it is finished.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>(string, float)-&gt;[string]</code>)</li>
</ul>
<h5>configure.libdir</h5>
<pre class="syntax ">string</pre>
<p>
Liquidsoap's library directory.
</p>
<h5>configure.logdir</h5>
<pre class="syntax ">string</pre>
<p>
Liquidsoap's logging directory.
</p>
<h5>configure.rundir</h5>
<pre class="syntax ">string</pre>
<p>
Liquidsoap's PID file directory.
</p>
<h5>enable_faad</h5>
<pre class="syntax ">()-&gt;unit</pre>
<p>
Enable faad decoding (needs faad binary in path)
</p>
<h5>enable_gstreamer</h5>
<pre class="syntax ">(?debug:bool)-&gt;unit</pre>
<p>
Enable gstreamer decoder (needs gst-launch binary in path)
</p>
<ul>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>)</li>
</ul>
<h5>enable_mplayer</h5>
<pre class="syntax ">(?debug:bool)-&gt;unit</pre>
<p>
Enable mplayer decoder (needs mplayer binary in path)
</p>
<ul>
<li>
<code>debug</code> (<code>bool</code> &ndash; defaults to <code>false</code>)</li>
</ul>
<h5>enable_replaygain_metadata</h5>
<pre class="syntax ">(?extract_replaygain:string)-&gt;unit</pre>
<p>
Enable replay gain metadata resolver. This resolver will 
process any file decoded by liquidsoap and add a <code>replay_gain</code> 
metadata when this value could be computed. For a finer-grained 
replay gain processing, use the <code>replay_gain</code> protocol.
</p>
<ul>
<li>
<code>extract_replaygain</code> (<code>string</code> &ndash; defaults to <code>&quot;/usr/local/lib/liquidsoap/svn/extract-replaygain&quot;</code>): The extraction program</li>
</ul>
<h5>execute</h5>
<pre class="syntax ">(string, ?string)-&gt;[string]</pre>
<p>
WARNING: This is DEPRECATED!
</p>
<p>
Execute a liquidsoap server command.
This operator is deprecated, in favor of 'server.execute'.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
</ul>
<h5>file.duration</h5>
<pre class="syntax ">(string)-&gt;float</pre>
<p>
Compute the duration in seconds of audio data contained in a file. The computation may be expensive. Returns -1. if computation failed, typically if the file was not recognized as valid audio.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>file.mime</h5>
<pre class="syntax ">(string)-&gt;string</pre>
<p>
Get the MIME type of a file, according to libmagic.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>get</h5>
<pre class="syntax ">(~default:'a, string)
 -&gt;'a where 'a is bool, int, float, string or [string]</pre>
<p>
Get a setting's value.
</p>
<ul>
<li>
<code>default</code> (<code>anything that is bool, int, float, string or [string]</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>liquidsoap.version</h5>
<pre class="syntax ">string</pre>
<p>
Liquidsoap version string.
</p>
<h5>playlist.parse</h5>
<pre class="syntax ">(string)-&gt;[([(string*string)]*string)]</pre>
<p>
Try to parse a local playlist. Return a list of (metadata,URI) items, where metadata is a list of (key,value) bindings.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>request.create</h5>
<pre class="syntax ">(?indicators:[string], ?persistent:bool,
 ?audio:bool, string)-&gt;request</pre>
<p>
Create a request. Creation may fail if there is no available RID, which cannot be detected currently: in that case one will obtain a request that will fail to be resolved.
</p>
<ul>
<li>
<code>indicators</code> (<code>[string]</code> &ndash; defaults to <code>[  ]</code>)</li>
<li>
<code>persistent</code> (<code>bool</code> &ndash; defaults to <code>false</code>)</li>
<li>
<code>audio</code> (<code>bool</code> &ndash; defaults to <code>true</code>): If set, resolving includes checking that the resulting file can be decoded as audio.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>request.destroy</h5>
<pre class="syntax ">(?force:bool, request)-&gt;unit</pre>
<p>
Destroying a request causes any temporary associated file to be deleted, and releases its RID. Persistent requests resist to destroying, unless forced.
</p>
<ul>
<li>
<code>force</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Destroy the request even if it is persistent.</li>
<li>
<code>(unlabeled)</code> (<code>request</code>)</li>
</ul>
<h5>request.filename</h5>
<pre class="syntax ">(request)-&gt;string</pre>
<p>
Return a valid local filename if the request is ready, and the empty string otherwise.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>request</code>)</li>
</ul>
<h5>request.ready</h5>
<pre class="syntax ">(request)-&gt;bool</pre>
<p>
Check if a request is ready, i.e. is associated to a valid local file. Unless the initial URI was such a file, a request has to be resolved before being ready.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>request</code>)</li>
</ul>
<h5>request.resolve</h5>
<pre class="syntax ">(?timeout:float, request)-&gt;bool</pre>
<p>
Resolve a request, i.e. attempt to get a valid local file. The operation can take some time. Return true if the resolving was successful, false otherwise (timeout or invalid URI).
</p>
<ul>
<li>
<code>timeout</code> (<code>float</code> &ndash; defaults to <code>30.</code>): Limit in seconds to the duration of the resolving.</li>
<li>
<code>(unlabeled)</code> (<code>request</code>)</li>
</ul>
<h5>server.execute</h5>
<pre class="syntax ">(string, ?string)-&gt;[string]</pre>
<p>
Execute a liquidsoap server command.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
</ul>
<h5>set</h5>
<pre class="syntax ">(string, 'a)
 -&gt;unit where 'a is bool, int, float, string or [string]</pre>
<p>
Change some setting. Use <code>liquidsoap --conf-descr</code> and <code>liquidsoap --conf-descr-key KEY</code> on the command-line to get some information about available settings.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>anything that is bool, int, float, string or [string]</code>)</li>
</ul>
<h5>shutdown</h5>
<pre class="syntax ">()-&gt;unit</pre>
<p>
Shutdown the application.
</p>
<h5>source.id</h5>
<pre class="syntax ">(source)-&gt;string</pre>
<p>
Get one source's identifier.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h5>source.skip</h5>
<pre class="syntax ">(source)-&gt;unit</pre>
<p>
Skip to the next track.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>source</code>)</li>
</ul>
<h3><a name="List">List</a></h3>
<h5>_[_]</h5>
<pre class="syntax ">(string, [(string*string)])-&gt;string</pre>
<p>
<code>l[k]</code> returns the first <code>v</code> such that <code>(k,v)</code> is in the list <code>l</code>.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>[(string*string)]</code>)</li>
</ul>
<h5>fst</h5>
<pre class="syntax ">(('a*'b))-&gt;'a</pre>
<p>
Get the first component of a pair.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>('a*'b)</code>)</li>
</ul>
<h5>list.append</h5>
<pre class="syntax ">(['a], ['a])-&gt;['a]</pre>
<p>
Catenate two lists.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>['a]</code>)</li>
<li>
<code>(unlabeled)</code> (<code>['a]</code>)</li>
</ul>
<h5>list.assoc</h5>
<pre class="syntax ">(string, [(string*string)])-&gt;string</pre>
<p>
Alias for the <code>l[k]</code> notation.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>): Key to look for</li>
<li>
<code>(unlabeled)</code> (<code>[(string*string)]</code>): List of pairs (key,value)</li>
</ul>
<h5>list.fold</h5>
<pre class="syntax ">((('a, 'b)-&gt;'a), 'a, ['b])-&gt;'a</pre>
<p>
Fold a function on every element of a list.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>('a, 'b)-&gt;'a</code>)</li>
<li>
<code>(unlabeled)</code> (<code>'a</code>)</li>
<li>
<code>(unlabeled)</code> (<code>['b]</code>)</li>
</ul>
<h5>list.hd</h5>
<pre class="syntax ">([string])-&gt;string</pre>
<p>
Return the head (first element) of a list, or “” if the list is empty.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>[string]</code>)</li>
</ul>
<h5>list.iter</h5>
<pre class="syntax ">((('a)-&gt;unit), ['a])-&gt;unit</pre>
<p>
Call a function on every element of a list.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>('a)-&gt;unit</code>)</li>
<li>
<code>(unlabeled)</code> (<code>['a]</code>)</li>
</ul>
<h5>list.length</h5>
<pre class="syntax ">(['a])-&gt;int</pre>
<p>
Get the length of a list, i.e. its number of elements.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>['a]</code>)</li>
</ul>
<h5>list.map</h5>
<pre class="syntax ">((('a)-&gt;'b), ['a])-&gt;['b]</pre>
<p>
Map a function on every element of a list.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>('a)-&gt;'b</code>)</li>
<li>
<code>(unlabeled)</code> (<code>['a]</code>)</li>
</ul>
<h5>list.mem</h5>
<pre class="syntax ">('a, ['a])-&gt;bool where 'a is an orderable type</pre>
<p>
Check if an element belongs to a list.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>anything that is an orderable type</code>)</li>
<li>
<code>(unlabeled)</code> (<code>['a] where 'a is an orderable type</code>)</li>
</ul>
<h5>list.mem_assoc</h5>
<pre class="syntax ">(string, [(string*string)])-&gt;bool</pre>
<p>
list.mem_assoc(key,l) returns true if l contains a pair
(key,value)
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>): Key to look for</li>
<li>
<code>(unlabeled)</code> (<code>[(string*string)]</code>): List of pairs (key,value)</li>
</ul>
<h5>list.nth</h5>
<pre class="syntax ">(['a], int)-&gt;'a</pre>
<p>
Get the n-th element of a list.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>['a]</code>)</li>
<li>
<code>(unlabeled)</code> (<code>int</code>)</li>
</ul>
<h5>list.remove</h5>
<pre class="syntax ">('a, ['a])-&gt;['a]</pre>
<p>
Remove a value from a list.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>'a</code>)</li>
<li>
<code>(unlabeled)</code> (<code>['a]</code>)</li>
</ul>
<h5>list.remove_assoc</h5>
<pre class="syntax ">(string, [(string*string)])-&gt;[(string*string)]</pre>
<p>
Remove a pair from an associative list
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>): Key of pair to be removed</li>
<li>
<code>(unlabeled)</code> (<code>[(string*string)]</code>): List of pairs (key,value)</li>
</ul>
<h5>list.rev</h5>
<pre class="syntax ">(['a])-&gt;['a]</pre>
<p>
Revert list order.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>['a]</code>)</li>
</ul>
<h5>list.sort</h5>
<pre class="syntax ">((('a, 'a)-&gt;int), ['a])-&gt;['a]</pre>
<p>
Sort a list according to a comparison function.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>('a, 'a)-&gt;int</code>)</li>
<li>
<code>(unlabeled)</code> (<code>['a]</code>)</li>
</ul>
<h5>list.tl</h5>
<pre class="syntax ">(['a])-&gt;['a]</pre>
<p>
Return the list without its first element.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>['a]</code>)</li>
</ul>
<h5>snd</h5>
<pre class="syntax ">(('a*'b))-&gt;'b</pre>
<p>
Get the second component of a pair.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>('a*'b)</code>)</li>
</ul>
<h3><a name="Math">Math</a></h3>
<h5>*</h5>
<pre class="syntax ">('a, 'a)-&gt;'a where 'a is a number type</pre>
<p>
Multiplication of numbers.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>anything that is a number type</code>)</li>
<li>
<code>(unlabeled)</code> (<code>anything that is a number type</code>)</li>
</ul>
<h5>+</h5>
<pre class="syntax ">('a, 'a)-&gt;'a where 'a is a number type</pre>
<p>
Addition of numbers.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>anything that is a number type</code>)</li>
<li>
<code>(unlabeled)</code> (<code>anything that is a number type</code>)</li>
</ul>
<h5>-</h5>
<pre class="syntax ">('a, 'a)-&gt;'a where 'a is a number type</pre>
<p>
Substraction of numbers.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>anything that is a number type</code>)</li>
<li>
<code>(unlabeled)</code> (<code>anything that is a number type</code>)</li>
</ul>
<h5>/</h5>
<pre class="syntax ">('a, 'a)-&gt;'a where 'a is a number type</pre>
<p>
Division of numbers.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>anything that is a number type</code>)</li>
<li>
<code>(unlabeled)</code> (<code>anything that is a number type</code>)</li>
</ul>
<h5>abs</h5>
<pre class="syntax ">('a)-&gt;'a where 'a is a number type</pre>
<p>
Absolute value.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>anything that is a number type</code>)</li>
</ul>
<h5>bool_of_float</h5>
<pre class="syntax ">(float)-&gt;bool</pre>
<p>
Convert a float to a bool.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>float</code>)</li>
</ul>
<h5>bool_of_int</h5>
<pre class="syntax ">(int)-&gt;bool</pre>
<p>
Convert an int to a bool.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>int</code>)</li>
</ul>
<h5>dB_of_lin</h5>
<pre class="syntax ">(float)-&gt;float</pre>
<p>
Convert linear scale into decibels.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>float</code>)</li>
</ul>
<h5>float_of_int</h5>
<pre class="syntax ">(int)-&gt;float</pre>
<p>
Convert an int to a float.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>int</code>)</li>
</ul>
<h5>int_of_float</h5>
<pre class="syntax ">(float)-&gt;int</pre>
<p>
Convert a float to a int.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>float</code>)</li>
</ul>
<h5>lin_of_dB</h5>
<pre class="syntax ">(float)-&gt;float</pre>
<p>
Convert decibels into linear scale.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>float</code>)</li>
</ul>
<h5>pow</h5>
<pre class="syntax ">('a, 'a)-&gt;'a where 'a is a number type</pre>
<p>
Exponentiation of numbers.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>anything that is a number type</code>)</li>
<li>
<code>(unlabeled)</code> (<code>anything that is a number type</code>)</li>
</ul>
<h5>random.float</h5>
<pre class="syntax ">(?min:float, ?max:float)-&gt;float</pre>
<p>
Generate a random value.
</p>
<ul>
<li>
<code>min</code> (<code>float</code> &ndash; defaults to <code>-1000000.</code>)</li>
<li>
<code>max</code> (<code>float</code> &ndash; defaults to <code>1000000.</code>)</li>
</ul>
<h5>~-</h5>
<pre class="syntax ">('a)-&gt;'a where 'a is a number type</pre>
<p>
Returns the opposite of its argument.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>anything that is a number type</code>)</li>
</ul>
<h3><a name="String">String</a></h3>
<h5>%</h5>
<pre class="syntax ">(string, [(string*string)])-&gt;string</pre>
<p>
<code>pattern % [...,(k,v),...]</code> changes in the pattern occurences of:
- <code>$(k)</code> into <code>v</code>;
- <code>$(if $(k2),"a","b")</code> into “a” if k2 is found in the list, “b” otherwise.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>[(string*string)]</code>)</li>
</ul>
<h5>^</h5>
<pre class="syntax ">(string, string)-&gt;string</pre>
<p>
Concatenate strings.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>bool_of_string</h5>
<pre class="syntax ">(?default:bool, string)-&gt;bool</pre>
<p>
Convert a string to a bool.
</p>
<ul>
<li>
<code>default</code> (<code>bool</code> &ndash; defaults to <code>false</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>float_of_string</h5>
<pre class="syntax ">(?default:float, string)-&gt;float</pre>
<p>
Convert a string to a float.
</p>
<ul>
<li>
<code>default</code> (<code>float</code> &ndash; defaults to <code>0.</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>int_of_string</h5>
<pre class="syntax ">(?default:int, string)-&gt;int</pre>
<p>
Convert a string to a int.
</p>
<ul>
<li>
<code>default</code> (<code>int</code> &ndash; defaults to <code>0</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>lastfm.uri</h5>
<pre class="syntax ">(?user:string, ?password:string, ?discovery:bool,
 ?string)-&gt;string</pre>
<p>
Utility to compose last.fm URIs.
</p>
<ul>
<li>
<code>user</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Lastfm user</li>
<li>
<code>password</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>): Lastfm password</li>
<li>
<code>discovery</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Allow lastfm suggestions</li>
<li>
<code>(unlabeled)</code> (<code>string</code> &ndash; defaults to <code>&quot;globaltags/creative-commons&quot;</code>): URI, e.g. user/toots5446/playlist, globaltags/rocksteady.</li>
</ul>
<h5>quote</h5>
<pre class="syntax ">(string)-&gt;string</pre>
<p>
Escape shell metacharacters.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>string.capitalize</h5>
<pre class="syntax ">(?capitalize:bool, ?space_sensitive:bool, string)
 -&gt;string</pre>
<p>
Return a string with the first character set to upper case (capitalize), or to lower case (uncapitalize).
</p>
<ul>
<li>
<code>capitalize</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Capitalize if true, uncapitalize otherwise</li>
<li>
<code>space_sensitive</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Capitalize each space seperated sub-string.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>string.case</h5>
<pre class="syntax ">(?lower:bool, string)-&gt;string</pre>
<p>
Convert a string to lower or upper case.
</p>
<ul>
<li>
<code>lower</code> (<code>bool</code> &ndash; defaults to <code>true</code>): Convert to lower case if true and uppercase otherwise.</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>string.concat</h5>
<pre class="syntax ">(?separator:string, [string])-&gt;string</pre>
<p>
Concatenate strings.
</p>
<ul>
<li>
<code>separator</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>(unlabeled)</code> (<code>[string]</code>)</li>
</ul>
<h5>string.extract</h5>
<pre class="syntax ">(~pattern:string, string)-&gt;[(string*string)]</pre>
<p>
Extract substrings from a string. 
Perl compatible regular expressions are recognized. Hence, special characters should be escaped. 
Returns a list of (index,value).
If the list does not have a pair associated to some index, it means that the corresponding pattern was not found.
</p>
<ul>
<li>
<code>pattern</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>string.match</h5>
<pre class="syntax ">(~pattern:string, string)-&gt;bool</pre>
<p>
Match a string with an expression. 
Perl compatible regular expressions are recognized. Hence, special characters should be escaped.
</p>
<ul>
<li>
<code>pattern</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>string.ref</h5>
<pre class="syntax ">(string)-&gt;((()-&gt;string)*((string)-&gt;unit))</pre>
<p>
Returns a pair (get,set) where get is a function of type <code>unit -&gt; string</code>, to get current value, and set a function of type <code>string -&gt; unit</code>, to set a new value. 
This is a workaround, and it shall be removed when variable references are implemented.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>): Initial value</li>
</ul>
<h5>string.replace</h5>
<pre class="syntax ">(~pattern:string, ((string)-&gt;string), string)
 -&gt;string</pre>
<p>
Replace substrings in a string. 
Will replace all substrings matched in the pattern by the string returned by the replace function.
</p>
<ul>
<li>
<code>pattern</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>(string)-&gt;string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>string.split</h5>
<pre class="syntax ">(~separator:string, string)-&gt;[string]</pre>
<p>
Split a string at 'separator'. 
Perl compatible regular expressions are recognized. Hence, special characters should be escaped.
</p>
<ul>
<li>
<code>separator</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>string_of</h5>
<pre class="syntax ">('a)-&gt;string</pre>
<p>
Return the representation of a value.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>'a</code>)</li>
</ul>
<h3><a name="System">System</a></h3>
<h5>argv</h5>
<pre class="syntax ">(?default:string, int)-&gt;string</pre>
<p>
Get command-line parameters.
</p>
<ul>
<li>
<code>default</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>(unlabeled)</code> (<code>int</code>)</li>
</ul>
<h5>basename</h5>
<pre class="syntax ">(string)-&gt;string</pre>
<p>
Get the base name of a path.
Implemented using the corresponding shell command.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>): Path</li>
</ul>
<h5>dirname</h5>
<pre class="syntax ">(string)-&gt;string</pre>
<p>
Get the directory name of a path.
Implemented using the corresponding shell command.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>): Path</li>
</ul>
<h5>exec_at</h5>
<pre class="syntax ">(?freq:float, ~pred:(()-&gt;bool), (()-&gt;unit))-&gt;unit</pre>
<p>
Execute a given action when a predicate is true. This will be run in background.
</p>
<ul>
<li>
<code>freq</code> (<code>float</code> &ndash; defaults to <code>1.</code>): Frequency for checking the predicate, in seconds.</li>
<li>
<code>pred</code> (<code>()-&gt;bool</code>): Predicate, typically a time interval such as <code>{10h-10h30}</code>.</li>
<li>
<code>(unlabeled)</code> (<code>()-&gt;unit</code>): Function to execute when the predicate is true.</li>
</ul>
<h5>get_process_lines</h5>
<pre class="syntax ">(string)-&gt;[string]</pre>
<p>
Perform a shell call and return the list of its output lines.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>get_process_output</h5>
<pre class="syntax ">(string)-&gt;string</pre>
<p>
Perform a shell call and return its output.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>getopt</h5>
<pre class="syntax ">(?default:string, string)-&gt;string</pre>
<p>
Parse command line options:
<code>getopt("-o")</code> returns “1” if “-o” was passed without any parameter, “0” otherwise.
<code>getopt(default="X","-o")</code> returns “Y” if “-o Y” was passed, “X” otherwise.
The result is removed from the list of arguments, affecting subsequent
calls to <code>argv()</code> and <code>getopt()</code>.
</p>
<ul>
<li>
<code>default</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>getpid</h5>
<pre class="syntax ">()-&gt;int</pre>
<p>
Get the process' pid.
</p>
<h5>log</h5>
<pre class="syntax ">(?label:string, ?level:int, string)-&gt;unit</pre>
<p>
Log a message.
</p>
<ul>
<li>
<code>label</code> (<code>string</code> &ndash; defaults to <code>&quot;lang&quot;</code>)</li>
<li>
<code>level</code> (<code>int</code> &ndash; defaults to <code>3</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>on_shutdown</h5>
<pre class="syntax ">((()-&gt;unit))-&gt;unit</pre>
<p>
Register a function to be called when Liquidsoap shuts down.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>()-&gt;unit</code>)</li>
</ul>
<h5>read</h5>
<pre class="syntax ">(?hide:bool)-&gt;string</pre>
<p>
Read some value from standard input (console).
</p>
<ul>
<li>
<code>hide</code> (<code>bool</code> &ndash; defaults to <code>false</code>): Hide typed characters (for passwords).</li>
</ul>
<h5>server.register</h5>
<pre class="syntax ">(?namespace:string, ?description:string,
 ?usage:string, string, ((string)-&gt;string))-&gt;unit</pre>
<p>
Register a command. You can then execute this function through the server, either telnet or socket.
</p>
<ul>
<li>
<code>namespace</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>description</code> (<code>string</code> &ndash; defaults to <code>&quot;No documentation available.&quot;</code>): A description of your command.</li>
<li>
<code>usage</code> (<code>string</code> &ndash; defaults to <code>&quot;&quot;</code>)</li>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>(string)-&gt;string</code>)</li>
</ul>
<h5>system</h5>
<pre class="syntax ">(string)-&gt;unit</pre>
<p>
Shell command call. Set verbose to true to log process' output and errors.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
</ul>
<h5>test_process</h5>
<pre class="syntax ">(string)-&gt;bool</pre>
<p>
Return true if process exited with 0 code.
Command should return quickly.
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>): Command to test</li>
</ul>
<h3><a name="Uncategorized">Uncategorized</a></h3>
<h5>replaygain_protocol</h5>
<pre class="syntax ">(string, 'a)-&gt;[string]</pre>
<p>
Register the replaygain protocol
</p>
<ul>
<li>
<code>(unlabeled)</code> (<code>string</code>)</li>
<li>
<code>(unlabeled)</code> (<code>'a</code>)</li>
</ul>
      <div id="footer"> 2003-2017 Savonet team</div>
    </div>
  </div>
  <script type="text/javascript" src="http://www.google.com/cse/brand?form=cse-search-box&amp;lang=en"></script>
  <script type="text/javascript" src="../js/search.js"></script>
  <script type="text/javascript">
    var _gaq = _gaq || [];
    _gaq.push(['_setAccount', 'UA-927362-1']);
    _gaq.push(['_trackPageview']);
    (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
    })();
  </script>
</body>
</html>
